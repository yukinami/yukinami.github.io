<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jyong&#39;s Blog</title>
  <subtitle>人生の目的の一つは楽しむことです</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yukinami.github.io/"/>
  <updated>2017-03-24T10:06:03.000Z</updated>
  <id>http://yukinami.github.io/</id>
  
  <author>
    <name>Jyong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker compose使用默认的bridge网络</title>
    <link href="http://yukinami.github.io/2017/03/24/Docker-compose%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E7%9A%84bridge%E7%BD%91%E7%BB%9C/"/>
    <id>http://yukinami.github.io/2017/03/24/Docker-compose使用默认的bridge网络/</id>
    <published>2017-03-24T09:54:52.000Z</published>
    <updated>2017-03-24T10:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先compose默认会为当前的compose建立单独的网络，然后所有的服务连接到这个网络。如果需要定义默认连接到自定义的网络，需要这样定义</p>
<a id="more"></a>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">networks:</span></div><div class="line"><span class="attr">  default:</span></div><div class="line">    <span class="comment"># Use a custom driver</span></div><div class="line"><span class="attr">    driver:</span> custom-driver<span class="bullet">-1</span></div></pre></td></tr></table></figure>
<p>如果是自定义的外部网络</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">networks:</span></div><div class="line"><span class="symbol">  default:</span></div><div class="line"><span class="symbol">    external:</span></div><div class="line"><span class="symbol">      name:</span> my-pre-existing-network</div></pre></td></tr></table></figure>
<p>如果外部网络使用的是docker默认的<code>bridge</code>网络，会报如下错误</p>
<blockquote>
<p>Network-scoped alias is supported only for containers in user defined networks</p>
</blockquote>
<p>原因是compose依赖网络范围的别名，如果使用外部的bridge网络，他仍然会尝试设置别名，但是网络别名只能设置在用户定义的网络上，默认的网络是不能设置别名的，所以报错。可以设置network_mode，来关闭compose内置的alias功能，让他使用网络默认的别名。</p>
<p>但是默认的<code>bridge</code>中无法设置别名，也就不存在默认的别名，service之间的网络通信又是依赖于别名的。</p>
<p>所以结论上讲，compose中的service是无法使用默认的<code>bridge</code>网络进行通信的，必须使用用户自定义的网络，外部定义或者compose中定义均可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先compose默认会为当前的compose建立单独的网络，然后所有的服务连接到这个网络。如果需要定义默认连接到自定义的网络，需要这样定义&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://yukinami.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC 模型类绑定</title>
    <link href="http://yukinami.github.io/2016/12/06/Spring-MVC-%E6%A8%A1%E5%9E%8B%E7%B1%BB%E7%BB%91%E5%AE%9A/"/>
    <id>http://yukinami.github.io/2016/12/06/Spring-MVC-模型类绑定/</id>
    <published>2016-12-06T05:37:42.000Z</published>
    <updated>2016-12-06T05:44:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Spring MVC的时候有一个很普通的需求，根据url中传递的id参数，查询并绑定绑定到一个实体对象</p>
<a id="more"></a>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="meta">@RequestMapping(<span class="meta-string">"/users"</span>)</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</div><div class="line"></div><div class="line">  <span class="meta">@Autowired</span></div><div class="line">  <span class="keyword">public</span> UserController(UserRepository userRepository) &#123;</div><div class="line">    Assert.notNull(repository, <span class="string">"Repository must not be null!"</span>);</div><div class="line">    <span class="keyword">this</span>.userRepository = userRepository;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@RequestMapping(<span class="meta-string">"/&#123;id&#125;"</span>)</span></div><div class="line">  <span class="keyword">public</span> String showUserForm(<span class="meta">@PathVariable(<span class="meta-string">"id"</span>)</span> <span class="built_in">Long</span> id, Model model) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// Do null check for id</span></div><div class="line">    User user = userRepository.findOne(id);</div><div class="line">    <span class="comment">// Do null check for user</span></div><div class="line"></div><div class="line">    model.addAttribute(<span class="string">"user"</span>, user);</div><div class="line">    <span class="keyword">return</span> <span class="string">"user"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>Spring Data</em>提供的<code>DomainClassPropertyEditorRegistrar</code>能够自动地查找所有注册的<em>Spring Data repositories</em>，并使用它进行查询转换</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"….web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"</span>&gt;</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"webBindingInitializer"</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"….web.bind.support.ConfigurableWebBindingInitializer"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"propertyEditorRegistrars"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.repository.support.DomainClassPropertyEditorRegistrar"</span> /&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<p>上面的代码即可简化为</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="meta">@RequestMapping(<span class="meta-string">"/users"</span>)</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@RequestMapping(<span class="meta-string">"/&#123;id&#125;"</span>)</span></div><div class="line">  <span class="keyword">public</span> String showUserForm(<span class="meta">@PathVariable(<span class="meta-string">"id"</span>)</span> User user, Model model) &#123;</div><div class="line"></div><div class="line">    model.addAttribute(<span class="string">"user"</span>, user);</div><div class="line">    <span class="keyword">return</span> <span class="string">"userForm"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同时使用了PropertyEditors转换后，还能够继续对User对象填充页面的提交的值，这在JPA更新的场合极为方便，省去了手动Merge的过程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用Spring MVC的时候有一个很普通的需求，根据url中传递的id参数，查询并绑定绑定到一个实体对象&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring Data" scheme="http://yukinami.github.io/tags/Spring-Data/"/>
    
      <category term="Spring MVC" scheme="http://yukinami.github.io/tags/Spring-MVC/"/>
    
  </entry>
  
  <entry>
    <title>Spring circular dependency</title>
    <link href="http://yukinami.github.io/2016/12/06/Spring-circular-dependency/"/>
    <id>http://yukinami.github.io/2016/12/06/Spring-circular-dependency/</id>
    <published>2016-12-06T03:22:02.000Z</published>
    <updated>2016-12-06T05:33:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>当发生类似 <code>Bean#1 -&gt; Bean#2 -&gt; Bean#1</code> 的依赖时，Spring框架通常能够自动的进行处理</p>
<blockquote>
<p>You can generally trust Spring to do the right thing. It detects configuration problems, such as references to non-existent beans and circular dependencies, at container load-time. Spring sets properties and resolves dependencies as late as possible, when the bean is actually created.</p>
</blockquote>
<a id="more"></a>
<p>如果出现<code>BeanCurrentlyInCreationException</code>异常，通常时因为使用了构造方法注入而产生的“鸡生蛋”的问题。解决方法就是使用setter方法注入。</p>
<p>如果使用setter方法依然产生这个问题，例如下面的错误</p>
<blockquote>
<p>Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name ‘asyncVerifyServiceImpl’: Bean with name ‘asyncVerifyServiceImpl’ has been injected into other beans [verifyServiceImpl] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using ‘getBeanNamesOfType’ with the ‘allowEagerInit’ flag turned off, for example.</p>
</blockquote>
<p>如果循环依赖的中的一个对象最终还会被代理（例如这里包含@Async方法的Bean），就会出这个错。解决方法是在这个Bean上使用@Lazy在延迟这个对象的初始化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当发生类似 &lt;code&gt;Bean#1 -&amp;gt; Bean#2 -&amp;gt; Bean#1&lt;/code&gt; 的依赖时，Spring框架通常能够自动的进行处理&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You can generally trust Spring to do the right thing. It detects configuration problems, such as references to non-existent beans and circular dependencies, at container load-time. Spring sets properties and resolves dependencies as late as possible, when the bean is actually created.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Spring Framework" scheme="http://yukinami.github.io/tags/Spring-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Nutch爬虫开发</title>
    <link href="http://yukinami.github.io/2016/09/23/Nutch%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91/"/>
    <id>http://yukinami.github.io/2016/09/23/Nutch爬虫开发/</id>
    <published>2016-09-23T06:22:35.000Z</published>
    <updated>2016-09-23T06:27:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nutch爬虫开发"><a href="#Nutch爬虫开发" class="headerlink" title="Nutch爬虫开发"></a>Nutch爬虫开发</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Nutch是一个用Java实现的搜索引擎，它包括全文搜索和网络爬虫。它支持针对不同的业务场景，使用本地运行模式或者基于Hadoop的分布式运行模式。</p>
<p>Nutch目前主要由1.x和2.x两个分支，主要的不同在于数据存储的实现。这里的存储指的是，Nutch本身会保存关于爬取过程中的爬虫的各种状态到称为<em>crawldb</em>的存储中去。1.x是以SequenceFile结构的方式保存到本地或者分布式文件系统中去，而2.x则是把存储层抽象了出来，不再依赖特定的存储结构，而是使用<a href="https://gora.apache.org/" target="_blank" rel="external">gora</a>来处理存储映射，所以最终可以保存到gora支持的RDBMS、NOSQL（Mongodb、HBase）等各种存储中去。</p>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>从<a href="http://nutch.apache.org/downloads.html" target="_blank" rel="external">这里</a>下载最新的源码包。执行</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ant</span> <span class="keyword">runtime</span></div></pre></td></tr></table></figure>
<p>会进行依赖包的下载、源码的编译、运行环境的构建等步骤。执行完毕后，</p>
<ul>
<li><code>runtime/local</code>目录是独立的本地运行环境</li>
<li><code>conf</code>、<code>build</code>、<code>runtime/deploy</code>目录则是分布式运行环境</li>
</ul>
<p>NOTE: 对Nutch的配置推荐直接修改<code>conf</code>目录下的配置，因为本地运行环境的构建是由这个目录构建出来的，<code>runtime/local</code>和它的关系相当于build和src的关系。</p>
<h2 id="爬取"><a href="#爬取" class="headerlink" title="爬取"></a>爬取</h2><p>网页的爬取可以通过<code>bin</code>目录下的<code>crawl</code>脚本进行自动的爬取，也可以通过<code>nutch</code>脚本进行分部爬虫。为了便于理解Nutch的爬取过程，这里以<code>nutch</code>脚本为例进行爬取。</p>
<p>Nutch的爬取过程分为五个步骤，每个步骤的执行结果都会保存到crawldb中，并通过<code>markers</code>字段记录执行到哪个阶段。</p>
<p>NOTE: 示例中使用Nutch2.3.1版本，并使用Mongodb作为存储。</p>
<h3 id="Inject"><a href="#Inject" class="headerlink" title="Inject"></a>Inject</h3><p>从文件中得到一批种子网页，把它们放到抓取数据库中去</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.<span class="regexp">/nutch inject ./u</span>rls<span class="regexp">/</span></div></pre></td></tr></table></figure>
<p>参数</p>
<ul>
<li><code>./urls/</code>为要爬去的url的目录</li>
<li>后面可以跟-crawlId，不加的话默认值为空</li>
</ul>
<p>crawlId对应crawldb中的表名，规则为<code>${crawlId}_webpage</code>。也就是说不加-crawlId参数的情况下，数据会进入<code>webpage</code>表中。</p>
<p>执行结果</p>
<p><img src="/img/nutch-inject.png" alt=""></p>
<h3 id="Generate"><a href="#Generate" class="headerlink" title="Generate"></a>Generate</h3><p>从抓取数据库中产生要抓取的页面放到抓取队列中去，产生batchJob。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./nutch <span class="keyword">generate</span></div></pre></td></tr></table></figure>
<p>该任务调用<code>FetchSchedule</code>来计算哪些url需要爬取。下面是官网wiki中关于任务的描述</p>
<blockquote>
<p>The generate command looks up in the crawl db for all the urls due for fetch and regroup them in a segment. An url is due for fetch if it is either a new url or if it is time to re-crawl it. </p>
</blockquote>
<p>包括Inject的Url以及fetchInterval时间已到的数据。</p>
<p>参数</p>
<ul>
<li>crawlId为必须的参数，为空的情况下使用<code>&#39;&#39;</code></li>
<li>可以指定batchId，也可以让其生成随机值，batchId用于后续的任务选择</li>
</ul>
<p>执行结果</p>
<p><img src="/img/nutch-generate.png" alt=""></p>
<h3 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h3><p>对抓取队列中的网页进行抓取，在reducer中使用了生产/消费者模型</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./nutch fetch -<span class="keyword">all</span></div></pre></td></tr></table></figure>
<p>参数</p>
<ul>
<li>batchId为必须的参数，上一步指定或生成的batchId，或者<code>-all</code></li>
<li>crawlId为必须的参数，不加参数的情况下使用默认空值</li>
</ul>
<p>该步骤处理的webpage的条件是gnmrk和batchId一致。</p>
<p>执行结果</p>
<p><img src="/img/nutch-fetch.png" alt=""></p>
<h3 id="Parse"><a href="#Parse" class="headerlink" title="Parse"></a>Parse</h3><p>对抓取完成的网页进行解析，产生一些新的链接与网页内容的解析结果</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./nutch <span class="built_in">parse</span> -<span class="built_in">all</span></div></pre></td></tr></table></figure>
<p>参数</p>
<ul>
<li>batchId为必须的参数，上一步指定或生成的batchId，或者<code>-all</code></li>
<li>crawlId为必须的参数，不加参数的情况下使用默认空值</li>
</ul>
<p>该步骤处理的webpage的条件是ftcmrk和batchId一致。</p>
<p>执行结果</p>
<p><img src="/img/nutch-parse.png" alt=""></p>
<h3 id="Updatedb"><a href="#Updatedb" class="headerlink" title="Updatedb"></a>Updatedb</h3><p>把新产生的链接更新到抓取数据库中去</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./nutch updatedb -<span class="keyword">all</span></div></pre></td></tr></table></figure>
<p>参数</p>
<ul>
<li>batchId为必须的参数，上一步指定或生成的batchId，或者<code>-all</code></li>
<li>crawlId为必须的参数，不加参数的情况下使用默认空值</li>
</ul>
<p>该步骤处理的webpage的条件是gnmrk和batchId一致。</p>
<p>执行结果</p>
<p><img src="/img/nutch-updatedb.png" alt=""></p>
<h3 id="Crawl脚本"><a href="#Crawl脚本" class="headerlink" title="Crawl脚本"></a>Crawl脚本</h3><p>Crawl脚本的执行的流程是先执行Inject，然后循环执行Genrate、Fetch、Parse、Updatedb。 循环的次数依赖于<code>numberOfRounds</code>参数，同时先是爬取的深度。</p>
<h3 id="关于FetchTime的更新"><a href="#关于FetchTime的更新" class="headerlink" title="关于FetchTime的更新"></a>关于FetchTime的更新</h3><p>Webpage中的FetchTime是Generator的重要参考值，字段更新规则如下</p>
<ul>
<li>Inject和Fetch会更新fetchTime成当前时间</li>
<li>Updatedb会更新fetchTime为当前时间+fetchInternal</li>
</ul>
<h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h2 id="IDEA中使用"><a href="#IDEA中使用" class="headerlink" title="IDEA中使用"></a>IDEA中使用</h2><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><p>先转换成eclipse工程后导入即可</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">ant eclipse</span></div></pre></td></tr></table></figure>
<p>Test目录标记成test，并且把src和test输出到不同的目录，避免测试代码干扰正常的执行。</p>
<p><img src="/img/mark-test.png" alt=""></p>
<p><img src="/img/set-output.png" alt=""></p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>通过分别运行<code>InjectorJob</code>，<code>GeneratorJob</code>，<code>FetcherJob</code>，<code>ParseJob</code>，<code>DBUpdaterJob</code>类的Main方法可即可执行各个爬取步骤。</p>
<p>NOTE: Working Directory要修改到<code>build</code>目录，才能正确获取到正确的运行环境。</p>
<p><img src="/img/working-dir.png" alt=""></p>
<h3 id="插件更新"><a href="#插件更新" class="headerlink" title="插件更新"></a>插件更新</h3><p>插件源码的修改需要更新<code>build</code>目录中的class文件及配置。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ant</span> <span class="keyword">compile</span> resolve-test</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Nutch爬虫开发&quot;&gt;&lt;a href=&quot;#Nutch爬虫开发&quot; class=&quot;headerlink&quot; title=&quot;Nutch爬虫开发&quot;&gt;&lt;/a&gt;Nutch爬虫开发&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Nutch是一个用Java实现的搜索引擎，它包括全文搜索和网络爬虫。它支持针对不同的业务场景，使用本地运行模式或者基于Hadoop的分布式运行模式。&lt;/p&gt;
&lt;p&gt;Nutch目前主要由1.x和2.x两个分支，主要的不同在于数据存储的实现。这里的存储指的是，Nutch本身会保存关于爬取过程中的爬虫的各种状态到称为&lt;em&gt;crawldb&lt;/em&gt;的存储中去。1.x是以SequenceFile结构的方式保存到本地或者分布式文件系统中去，而2.x则是把存储层抽象了出来，不再依赖特定的存储结构，而是使用&lt;a href=&quot;https://gora.apache.org/&quot;&gt;gora&lt;/a&gt;来处理存储映射，所以最终可以保存到gora支持的RDBMS、NOSQL（Mongodb、HBase）等各种存储中去。&lt;/p&gt;
    
    </summary>
    
    
      <category term="爬虫" scheme="http://yukinami.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Nutch" scheme="http://yukinami.github.io/tags/Nutch/"/>
    
  </entry>
  
  <entry>
    <title>实现后台长时间任务的监控</title>
    <link href="http://yukinami.github.io/2016/09/05/%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E9%95%BF%E6%97%B6%E9%97%B4%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%9B%91%E6%8E%A7/"/>
    <id>http://yukinami.github.io/2016/09/05/实现后台长时间任务的监控/</id>
    <published>2016-09-05T10:00:01.000Z</published>
    <updated>2016-09-06T07:23:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>后台长时间任务的监控，例如，处理进度的监控，可以通过客户端轮询拉或者服务器推技术来实现。这里主要讨论服务器推技术的实现。</p>
<h2 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h2><p>基于HTTP 长连接、无须在浏览器端安装插件的“服务器推”技术为“Comet”。Comet主要有两种实现方式。</p>
<h3 id="基于-AJAX-的长轮询（long-polling）方式"><a href="#基于-AJAX-的长轮询（long-polling）方式" class="headerlink" title="基于 AJAX 的长轮询（long-polling）方式"></a>基于 AJAX 的长轮询（long-polling）方式</h3><p><img src="http://www.ibm.com/developerworks/cn/web/wa-lo-comet/fig002.jpg" alt=""></p>
<p>使用 AJAX 实现“服务器推”与传统的 AJAX 应用不同之处在于</p>
<ol>
<li>服务器端会阻塞请求直到有数据传递或超时才返回。</li>
<li>客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。</li>
<li>当客户端处理接收的数据、重新建立连接时，服务器端可能有新的数据到达；这些信息会被服务器端保存直到客户端重新建立连接，客户端会一次把当前服务器端所有的信息取回。</li>
</ol>
<a id="more"></a>
<p>在这种长轮询方式下，客户端是在 XMLHttpRequest 的 readystate 为 4（即数据传输结束）时调用回调函数，进行信息处理。当 readystate 为 4 时，数据传输结束，连接已经关闭。Mozilla Firefox 提供了对 Streaming AJAX 的支持， 即 readystate 为 3 时（数据仍在传输中），客户端可以读取数据，从而无须关闭连接，就能读取处理服务器端返回的信息。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="type">XMLHttpRequest</span>();  </div><div class="line">xhr.previous_text = <span class="string">''</span>;</div><div class="line"> </div><div class="line"><span class="comment">//xhr.onload = function() &#123; log_message("[XHR] Done. responseText: &lt;i&gt;" + xhr.responseText + "&lt;/i&gt;"); &#125;;</span></div><div class="line">xhr.onerror = <span class="function"><span class="keyword">function</span></span>() &#123; log_message(<span class="string">"[XHR] Fatal Error."</span>); &#125;;</div><div class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span></span>() </div><div class="line">&#123;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (xhr.readyState &gt; <span class="number">2</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">var</span> <span class="keyword">new</span><span class="type">_response</span> = xhr.responseText.substring(xhr.previous_text.length);</div><div class="line">            <span class="keyword">var</span> result = JSON.parse( <span class="keyword">new</span><span class="type">_response</span> );</div><div class="line">            log_message(result.message);</div><div class="line">            <span class="comment">//update the progressbar</span></div><div class="line">            document.getElementById(<span class="string">'progressor'</span>).style.width = result.progress + <span class="string">"%"</span>;</div><div class="line">            xhr.previous_text = xhr.responseText;</div><div class="line">        &#125;   </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (e)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//log_message("&lt;b&gt;[XHR] Exception: " + e + "&lt;/b&gt;");</span></div><div class="line">    &#125;</div><div class="line">     </div><div class="line">     </div><div class="line">&#125;;</div><div class="line"></div><div class="line">xhr.open(<span class="string">"GET"</span>, <span class="string">"ajax_stream.php"</span>, <span class="literal">true</span>);</div><div class="line">xhr.send(<span class="string">"Making request..."</span>);</div></pre></td></tr></table></figure>
<h3 id="基于-Iframe-及-htmlfile-的流（streaming）方式"><a href="#基于-Iframe-及-htmlfile-的流（streaming）方式" class="headerlink" title="基于 Iframe 及 htmlfile 的流（streaming）方式"></a>基于 Iframe 及 htmlfile 的流（streaming）方式</h3><p><img src="http://www.ibm.com/developerworks/cn/web/wa-lo-comet/fig003.jpg" alt=""></p>
<p>iframe 是很早就存在的一种HTML标记，通过在HTML页面里嵌入一个隐蔵帧，然后将这个隐蔵帧的SRC属性设为对一个长连接的请求，服务器端就能源源不断地往客户端输入数据。iframe 服务器端并不返回直接显示在页面的数据，而是返回对客户端 Javascript 函数的调用，如<code>&lt;script type=&quot;text/javascript&quot;&gt;js_func(“data from server ”)&lt;/script&gt;</code>。服务器端将返回的数据作为客户端JavaScript函数的参数传递；客户端浏览器的Javascript引擎在收到服务器返回的JavaScript调用时就会去执行代码。</p>
<h2 id="Server-Send-Event"><a href="#Server-Send-Event" class="headerlink" title="Server Send Event"></a>Server Send Event</h2><p>HTML5提供了很多新的特性，其中包括的<em>Server Send Event</em>和<em>Websockets</em>能够更方便的实现服务器端推。<em>Websockets</em>的接口实现的是客户端和服务器端之间的双向通信，对应的开销也会更大。 对于我们这里的应用场景来说，只需要单向的服务器端退即可，所以使用SSE来实现更为合适。</p>
<h3 id="客户端的实现"><a href="#客户端的实现" class="headerlink" title="客户端的实现"></a>客户端的实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!!<span class="built_in">window</span>.EventSource) </div><div class="line">&#123;</div><div class="line">    <span class="keyword">var</span> source = <span class="keyword">new</span> EventSource(<span class="string">'task.php'</span>);</div><div class="line">     </div><div class="line">    source.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">console</span>.log(e.data);</div><div class="line">        <span class="comment">//Do whatever with e.data</span></div><div class="line">    &#125;, <span class="literal">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>客户端的实现很简单，只需要新建一个EventSource，参数为请求的地址，然后添加上listener即可。一旦添加完message listener之后，客户端就会发送请求，在这期间，如果服务器端长时间没有响应，那么，客户端会再次发送请求，直到调用<code>source.close()</code>方法。 所以客户端正常情况下，应该有个服务器端处理完，关闭source的逻辑。</p>
<h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><p>服务器端只需要在任务结束直接，不关闭response，然后然response中写符合特定格式的数据即可</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">id:</span>xxx</div><div class="line"><span class="symbol">data:</span>xxx</div></pre></td></tr></table></figure>
<p>Spring有对SSE的封装，下面以Spring为例，完整地演示后台任务进度的反馈</p>
<p>下面是Controller的代码，对SSE的调用需要在异步任务中进行，但是SSE并不属于应用层的逻辑，所以通过回调的方式传递给应用层。任务完成后需要调用complete方法，对应的客户端对complete之前返回的消息做特殊的响应，即关闭EventSource</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">SseEmitter sseEmitter = <span class="keyword">new</span> SseEmitter();</div><div class="line">fooService.batch<span class="function"><span class="params">((String id, String result, String message, boolean exception) -&gt; &#123;</span></span></div><div class="line">    String data = String.format(<span class="string">"%s,%s,%s"</span> , result, message, exception);</div><div class="line">    SseEmitter.SseEventBuilder eventBuilder = SseEmitter.event().id(id).data(data);</div><div class="line">    sseEmitter.send(eventBuilder);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (BATCH_COMPLETE.equals(result))&#123;</div><div class="line">        sseEmitter.complete();</div><div class="line">    &#125;</div><div class="line">&#125;, error -&gt; &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        sseEmitter.send(BATCH_COMPLETE);</div><div class="line">        sseEmitter.complete();</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        sseEmitter.completeWithError(e);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="title">return</span> <span class="title">sseEmitter</span>;</div></pre></td></tr></table></figure>
<p>应用层方法中，应该对每条批处理数据进行异步。异步使用Spring的<code>@Async</code>注解即可，但是这里需要注意的是，如果通过this调用自己类方法AOP代理是会失效的，因此需要用另外一个Bean来封装异步方法</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> batch(FooController.SSEBatchConsumer replyStatus, Consumer&lt;String&gt; replyError) &#123;</div><div class="line"></div><div class="line">	AtomicInteger <span class="keyword">count</span> = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>); </div><div class="line">	List&lt;Foo&gt; foos = <span class="keyword">this</span>.fooRepository.<span class="keyword">findAll</span>();</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (foos == <span class="keyword">null</span> || foos.<span class="keyword">size</span>() == <span class="number">0</span>) &#123;</div><div class="line">	    replyError.accept(<span class="keyword">null</span>);</div><div class="line">	    <span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (Foo foo : foos) &#123;</div><div class="line">	    <span class="keyword">this</span>.asyncService.doFoo(foo, foo.<span class="keyword">size</span>(), <span class="keyword">count</span>, replyStatus);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> AsyncService &#123;</div><div class="line">	@Async</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> asyncService(Foo fpp, <span class="keyword">int</span> total, AtomicInteger <span class="keyword">count</span>, RecruitmentsIndexController.SSEBatchConsumer replyStatus)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;后台长时间任务的监控，例如，处理进度的监控，可以通过客户端轮询拉或者服务器推技术来实现。这里主要讨论服务器推技术的实现。&lt;/p&gt;
&lt;h2 id=&quot;Comet&quot;&gt;&lt;a href=&quot;#Comet&quot; class=&quot;headerlink&quot; title=&quot;Comet&quot;&gt;&lt;/a&gt;Comet&lt;/h2&gt;&lt;p&gt;基于HTTP 长连接、无须在浏览器端安装插件的“服务器推”技术为“Comet”。Comet主要有两种实现方式。&lt;/p&gt;
&lt;h3 id=&quot;基于-AJAX-的长轮询（long-polling）方式&quot;&gt;&lt;a href=&quot;#基于-AJAX-的长轮询（long-polling）方式&quot; class=&quot;headerlink&quot; title=&quot;基于 AJAX 的长轮询（long-polling）方式&quot;&gt;&lt;/a&gt;基于 AJAX 的长轮询（long-polling）方式&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://www.ibm.com/developerworks/cn/web/wa-lo-comet/fig002.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用 AJAX 实现“服务器推”与传统的 AJAX 应用不同之处在于&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务器端会阻塞请求直到有数据传递或超时才返回。&lt;/li&gt;
&lt;li&gt;客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。&lt;/li&gt;
&lt;li&gt;当客户端处理接收的数据、重新建立连接时，服务器端可能有新的数据到达；这些信息会被服务器端保存直到客户端重新建立连接，客户端会一次把当前服务器端所有的信息取回。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="HTML" scheme="http://yukinami.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Java脚本调用</title>
    <link href="http://yukinami.github.io/2016/09/02/Java%E8%84%9A%E6%9C%AC%E8%B0%83%E7%94%A8/"/>
    <id>http://yukinami.github.io/2016/09/02/Java脚本调用/</id>
    <published>2016-09-02T09:40:22.000Z</published>
    <updated>2016-09-05T09:17:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JSR223"><a href="#JSR223" class="headerlink" title="JSR223"></a>JSR223</h2><p>Java中调用其他脚本语言可以通过JSR223来实现。JSR223规范定义了脚本调用的抽象，只要拥有对应脚本的JSR223的实现，即可实现Java对对应脚本的调用。</p>
<p>例如，下面是对JS脚本的调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.script.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ScriptException </span>&#123;</div><div class="line">        ScriptEngineManager manager = <span class="keyword">new</span> ScriptEngineManager();</div><div class="line">        ScriptEngine engine = manager.getEngineByName(<span class="string">"JavaScript"</span>);</div><div class="line">        engine.eval(<span class="string">"print ('Hello World')"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Ruby的调用"><a href="#Ruby的调用" class="headerlink" title="Ruby的调用"></a>Ruby的调用</h3><p><a href="http://jruby.org/" target="_blank" rel="external">JRuby</a>提供了Ruby脚本的的JSR223的实现。只需直接依赖JRuby的包</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jruby<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jruby<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$<span class="template-variable">&#123;jruby.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>引擎名为jruby</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ScriptEngineManager </span>manager = new <span class="keyword">ScriptEngineManager();</span></div><div class="line">       <span class="keyword">ScriptEngine </span>engine = manager.getEngineByName(<span class="string">"jruby"</span>)<span class="comment">;</span></div><div class="line">       <span class="keyword">Bindings </span><span class="keyword">bindings </span>= new SimpleBindings()<span class="comment">;</span></div><div class="line">       <span class="keyword">bindings.put("message", </span><span class="string">"global variable"</span>)<span class="comment">;</span></div><div class="line">       String <span class="keyword">script </span>=</div><div class="line">               <span class="string">"puts $message"</span><span class="comment">;</span></div><div class="line">       engine.eval(<span class="keyword">script, </span><span class="keyword">bindings);</span></div></pre></td></tr></table></figure>
<h4 id="使用gem"><a href="#使用gem" class="headerlink" title="使用gem"></a>使用gem</h4><p>Jruby增强了RubyGems，它会寻找classpath下的specifications目录并自动地添加到<code>Gem.path</code>目录下，这意味着可以把整个gem repository打包成jar文件。</p>
<p>首先，需要通过安装需要的gem的来创建gem repository</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ java -jar jruby-complete<span class="number">-1.1</span><span class="number">.6</span>.jar -S gem install -i ./chronic-gems chronic --no-rdoc --no-ri</div><div class="line">Successfully installed rubyforge<span class="number">-1.0</span><span class="number">.2</span></div><div class="line">Successfully installed rake<span class="number">-0.8</span><span class="number">.3</span></div><div class="line">Successfully installed hoe<span class="number">-1.8</span><span class="number">.2</span></div><div class="line">Successfully installed chronic<span class="number">-0.2</span><span class="number">.3</span></div><div class="line"><span class="number">4</span> gems installed</div></pre></td></tr></table></figure>
<p>然后打成jar包，注意jar包的名称不要和gem的名称一样（例如chronic.jar），否则当你<code>require &#39;chronic&#39;</code>的时候JRuby会加载chronic.jar</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="keyword">jar </span>cf chronic-gems.<span class="keyword">jar </span>-C chronic-gems .</div></pre></td></tr></table></figure>
<p>然后可以查看jar包中所包含的gem</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">java</span> <span class="selector-tag">-jar</span> <span class="selector-tag">jruby-complete-1</span><span class="selector-class">.1</span><span class="selector-class">.6</span><span class="selector-class">.jar</span> <span class="selector-tag">-S</span> <span class="selector-tag">gem</span> <span class="selector-tag">list</span></div></pre></td></tr></table></figure>
<h3 id="NodeJS的调用"><a href="#NodeJS的调用" class="headerlink" title="NodeJS的调用"></a>NodeJS的调用</h3><p><a href="https://github.com/eclipsesource/J2V8" target="_blank" rel="external">J2V8</a>是V8引擎的Java Binding，它通过JNI调用来实现NodeJS的调用。下面是一个调用NPM模块的例子</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">  final NodeJS nodeJS = NodeJS.createNodeJS();</div><div class="line">  final V8Object jimp = nodeJS.require(<span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"path_to_jimp_module"</span>));</div><div class="line"> </div><div class="line">  V8Function callback = <span class="keyword">new</span> V8Function(nodeJS.getRuntime(), <span class="keyword">new</span> JavaCallback() &#123;	</div><div class="line">    <span class="keyword">public</span> Object invoke(V8Object receiver, V8Array parameters) &#123;</div><div class="line">      final V8Object <span class="built_in">image</span> = parameters.getObject(<span class="number">1</span>);</div><div class="line">      executeJSFunction(<span class="built_in">image</span>, <span class="string">"posterize"</span>, <span class="number">7</span>);</div><div class="line">      executeJSFunction(<span class="built_in">image</span>, <span class="string">"greyscale"</span>);</div><div class="line">      executeJSFunction(<span class="built_in">image</span>, <span class="string">"write"</span>,  <span class="string">"path_to_output"</span>);</div><div class="line">      <span class="built_in">image</span>.<span class="built_in">release</span>();</div><div class="line">      <span class="built_in">return</span> null;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  executeJSFunction(jimp, <span class="string">"read"</span>, <span class="string">"path_to_image"</span>, callback);</div><div class="line"> </div><div class="line">  <span class="built_in">while</span>(nodeJS.isRunning()) &#123;</div><div class="line">    nodeJS.handleMessage();</div><div class="line">  &#125;		</div><div class="line">  callback.<span class="built_in">release</span>();</div><div class="line">  jimp.<span class="built_in">release</span>();</div><div class="line">  nodeJS.<span class="built_in">release</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Spring-Integration"><a href="#Spring-Integration" class="headerlink" title="Spring Integration"></a>Spring Integration</h2><p>Spring Integration 2.1开始支持对JSR223实现的集成调用。 通过Service Activator即可实现方法调用</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">service-activator</span> <span class="attr">input-channel</span>=<span class="string">"input"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script:script</span> <span class="attr">lang</span>=<span class="string">"ruby"</span> <span class="attr">variables</span>=<span class="string">"foo=FOO, date-ref=dateBean"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script:variable</span> <span class="attr">name</span>=<span class="string">"bar"</span> <span class="attr">ref</span>=<span class="string">"barBean"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script:variable</span> <span class="attr">name</span>=<span class="string">"baz"</span> <span class="attr">value</span>=<span class="string">"bar"</span>/&gt;</span></div><div class="line">        &lt;![CDATA[</div><div class="line">            payload.foo = foo</div><div class="line">            payload.date = date</div><div class="line">            payload.bar = bar</div><div class="line">            payload.baz = baz</div><div class="line">            payload</div><div class="line">        ]]&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">script:script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">service-activator</span>&gt;</span></div></pre></td></tr></table></figure>
<p>再配合Gateway，实现无缝的方法调用</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;gateway service-<span class="keyword">interface</span>=<span class="string">"com.some.Foo"</span></div><div class="line">             <span class="keyword">default</span>-request-channel=<span class="string">"input"</span></div><div class="line">             <span class="keyword">default</span>-reply-timeout=<span class="string">"10000"</span></div><div class="line">             <span class="keyword">default</span>-reply-channel=<span class="string">"reply"</span> /&gt;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JSR223&quot;&gt;&lt;a href=&quot;#JSR223&quot; class=&quot;headerlink&quot; title=&quot;JSR223&quot;&gt;&lt;/a&gt;JSR223&lt;/h2&gt;&lt;p&gt;Java中调用其他脚本语言可以通过JSR223来实现。JSR223规范定义了脚本调用的抽象，只要拥有对应脚本的JSR223的实现，即可实现Java对对应脚本的调用。&lt;/p&gt;
&lt;p&gt;例如，下面是对JS脚本的调用&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; javax.script.*;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HelloWorld&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; ScriptException &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        ScriptEngineManager manager = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ScriptEngineManager();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        ScriptEngine engine = manager.getEngineByName(&lt;span class=&quot;string&quot;&gt;&quot;JavaScript&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        engine.eval(&lt;span class=&quot;string&quot;&gt;&quot;print (&#39;Hello World&#39;)&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yukinami.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>用Spring Test进行页面的功能测试</title>
    <link href="http://yukinami.github.io/2016/05/28/%E7%94%A8Spring-Test%E8%BF%9B%E8%A1%8C%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <id>http://yukinami.github.io/2016/05/28/用Spring-Test进行页面的功能测试/</id>
    <published>2016-05-28T09:45:57.000Z</published>
    <updated>2016-05-28T11:31:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-Test"><a href="#Spring-Test" class="headerlink" title="Spring Test"></a>Spring Test</h2><p>Spring Test框架提供的MockMvc可用于实现Controller的集成测试。</p>
<p>例如</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">MockHttpServletRequestBuilder createMessage = post(<span class="string">"/messages/"</span>)</div><div class="line"><span class="meta">    .param</span>(<span class="string">"summary"</span>, <span class="string">"Spring Rocks"</span>)</div><div class="line"><span class="meta">    .param</span>(<span class="string">"text"</span>, <span class="string">"In case you didn't know, Spring Rocks!"</span>)<span class="comment">;</span></div><div class="line"></div><div class="line">mockMvc.perform(createMessage)</div><div class="line"><span class="meta">    .andExpect</span>(status().is3xxRedirection())</div><div class="line"><span class="meta">    .andExpect</span>(redirectedUrl(<span class="string">"/messages/123"</span>))<span class="comment">;</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果想更新一步，对页面的功能功能测试，也是可以的</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">String summaryParamName = <span class="string">"summary"</span><span class="comment">;</span></div><div class="line">String textParamName = <span class="string">"text"</span><span class="comment">;</span></div><div class="line">mockMvc.perform(get(<span class="string">"/messages/form"</span>))</div><div class="line"><span class="meta">        .andExpect</span>(xpath(<span class="string">"//input[@name='"</span> + summaryParamName + <span class="string">"']"</span>).exists())</div><div class="line"><span class="meta">        .andExpect</span>(xpath(<span class="string">"//textarea[@name='"</span> + textParamName + <span class="string">"']"</span>).exists())<span class="comment">;</span></div><div class="line"></div><div class="line">MockHttpServletRequestBuilder createMessage = post(<span class="string">"/messages/"</span>)</div><div class="line"><span class="meta">        .param</span>(summaryParamName, <span class="string">"Spring Rocks"</span>)</div><div class="line"><span class="meta">        .param</span>(textParamName, <span class="string">"In case you didn't know, Spring Rocks!"</span>)<span class="comment">;</span></div><div class="line"></div><div class="line">mockMvc.perform(createMessage)</div><div class="line"><span class="meta">        .andExpect</span>(status().is3xxRedirection())</div><div class="line"><span class="meta">        .andExpect</span>(redirectedUrl(<span class="string">"/messages/123"</span>))<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>但是这样的测试代码的有不少缺点，代码重复性较高，可维护性较差，页面稍微变更，现有的代码的xpath也不得不修改。 所以说并不适合用于页面功能测试</p>
<h2 id="集成HtmlUnit"><a href="#集成HtmlUnit" class="headerlink" title="集成HtmlUnit"></a>集成HtmlUnit</h2><p>HtmlUnit是一个headless的浏览器，它可以由Webdriver来驱动。通过这种方式来进行页面功能测试，使测试更为充分，同时测试脚本可以给测试组复用，用[Selenium]进行完整的E2E测试。</p>
<p>Spring Test可以和HtmlUnit集成，进行页面功能的测试，同时对于Controller依赖的其他对象，又可以注入Mock对象。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">HtmlPage createMsgFormPage = webClient.getPage(<span class="string">"http://localhost/messages/form"</span>)<span class="comment">;</span></div><div class="line"></div><div class="line">HtmlForm form = createMsgFormPage.getHtmlElementById(<span class="string">"messageForm"</span>)<span class="comment">;</span></div><div class="line">HtmlTextInput summaryInput = createMsgFormPage.getHtmlElementById(<span class="string">"summary"</span>)<span class="comment">;</span></div><div class="line">summaryInput.setValueAttribute(<span class="string">"Spring Rocks"</span>)<span class="comment">;</span></div><div class="line">HtmlTextArea textInput = createMsgFormPage.getHtmlElementById(<span class="string">"text"</span>)<span class="comment">;</span></div><div class="line">textInput.setText(<span class="string">"In case you didn't know, Spring Rocks!"</span>)<span class="comment">;</span></div><div class="line">HtmlSubmitInput <span class="keyword">submit </span>= form.getOneHtmlElementByAttribute(<span class="string">"input"</span>, <span class="string">"type"</span>, <span class="string">"submit"</span>)<span class="comment">;</span></div><div class="line">HtmlPage newMessagePage = <span class="keyword">submit.click();</span></div><div class="line"></div><div class="line">assertThat(newMessagePage.getUrl().toString()).endsWith(<span class="string">"/messages/123"</span>)<span class="comment">;</span></div><div class="line">String id = newMessagePage.getHtmlElementById(<span class="string">"id"</span>).getTextContent()<span class="comment">;</span></div><div class="line">assertThat(id).isEqualTo(<span class="string">"123"</span>)<span class="comment">;</span></div><div class="line">String summary = newMessagePage.getHtmlElementById(<span class="string">"summary"</span>).getTextContent()<span class="comment">;</span></div><div class="line">assertThat(summary).isEqualTo(<span class="string">"Spring Rocks"</span>)<span class="comment">;</span></div><div class="line">String text = newMessagePage.getHtmlElementById(<span class="string">"text"</span>).getTextContent()<span class="comment">;</span></div><div class="line">assertThat(text).isEqualTo(<span class="string">"In case you didn't know, Spring Rocks!"</span>)<span class="comment">;</span></div></pre></td></tr></table></figure>
<h2 id="集成Webdriver"><a href="#集成Webdriver" class="headerlink" title="集成Webdriver"></a>集成Webdriver</h2><p>由于Webdriver是支持HtmlUnit的，因此，可以使用Webdriver代码驱动，好处是测试脚本可以给E2E测试复用。</p>
<p>下面是用了<em>Page Object Pattern</em>的测试页面</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateMessagePage</span></span></div><div class="line">        extends AbstractPage &#123; </div><div class="line"></div><div class="line">    </div><div class="line">    <span class="keyword">private</span> WebElement summary;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> WebElement text;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="meta">@FindBy(css = <span class="meta-string">"input[type=submit]"</span>)</span></div><div class="line">    <span class="keyword">private</span> WebElement submit;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> CreateMessagePage(WebDriver driver) &#123;</div><div class="line">        <span class="keyword">super</span>(driver);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> &lt;T&gt; T createMessage(Class&lt;T&gt; resultPage, String summary, String details) &#123;</div><div class="line">        <span class="keyword">this</span>.summary.sendKeys(summary);</div><div class="line">        <span class="keyword">this</span>.text.sendKeys(details);</div><div class="line">        <span class="keyword">this</span>.submit.click();</div><div class="line">        <span class="keyword">return</span> PageFactory.initElements(driver, resultPage);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> static CreateMessagePage to(WebDriver driver) &#123;</div><div class="line">        <span class="comment">// driver.get("http://localhost:8080/messages/form");</span></div><div class="line">        <span class="keyword">get</span>(driver, <span class="string">"messages/form"</span>);</div><div class="line">        <span class="keyword">return</span> PageFactory.initElements(driver, CreateMessagePage.<span class="keyword">class</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试逻辑</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CreateMessagePage page = CreateMessagePage.to<span class="comment">(driver)</span>;</div><div class="line">ViewMessagePage viewMessagePage =</div><div class="line">    page.createMessage<span class="comment">(ViewMessagePage.class, expectedSummary, expectedText)</span>;</div><div class="line">    </div><div class="line">assertThat<span class="comment">(viewMessagePage.getMessage()</span>).isEqualTo<span class="comment">(expectedMessage)</span>;</div><div class="line">assertThat<span class="comment">(viewMessagePage.getSuccess()</span>).isEqualTo<span class="comment">("Successfully created a new message")</span>;</div></pre></td></tr></table></figure>
<h3 id="关于Page-Object-Pattern"><a href="#关于Page-Object-Pattern" class="headerlink" title="关于Page Object Pattern"></a>关于<em>Page Object Pattern</em></h3><p>页面对象模式通过面向对象的方式把页面封装起来。无论是页面的元素，还是对页面的操作，都可以封装起来的，这大大提供了测试代码的复用率。 同时对页面的操作只需要通过调用方法即可实现，如同在浏览器页面上点选按钮一般简单，甚至对于一些复杂的流程操作，比直接在浏览器页面中操作更为高效。</p>
<h2 id="集成Gab"><a href="#集成Gab" class="headerlink" title="集成Gab"></a>集成Gab</h2><p>Geb是一个Groovy的浏览器自动测试框架。它使用webdriver来驱动对页面的操作。可以把它理解为针对<em>Page Object Pattern</em>对Webdriver进行了更高层次的封装。利用它，可以更为方便的操作页面对象。同时它能够集成spock，能够很大程度的提高测试代码的质量。</p>
<p>下面是使用Geb进行页面功能测试的一个例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserIndexPage</span> <span class="keyword">extends</span> <span class="title">Page</span> </span>&#123;</div><div class="line"></div><div class="line">    static url = <span class="string">"/users"</span></div><div class="line">    static at = &#123; title == <span class="string">"My website - Users"</span> &#125;</div><div class="line">    static content = &#123;</div><div class="line">        menu &#123; $(<span class="string">"ul.nav.navbar-nav li"</span>, <span class="number">2</span>) &#125;</div><div class="line">        homeMenuButton &#123; $(<span class="string">"ul.nav.navbar-nav li:first-child a"</span>) &#125;</div><div class="line">        usersTable &#123; $(<span class="string">"table"</span>, <span class="number">0</span>) &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserIndexIntegrationTests</span> <span class="keyword">extends</span> <span class="title">GebReportingSpec</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="type">WebApplicationContext</span> context</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span></span>() &#123;</div><div class="line">        browser.driver = <span class="type">MockMvcHtmlUnitDriverBuilder</span></div><div class="line">                .webAppContextSetup(context, springSecurity()).build()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> "<span class="title">go</span> <span class="title">to</span> <span class="title">users</span>"</span>() &#123;</div><div class="line">        when:</div><div class="line">        to <span class="type">UserIndexPage</span></div><div class="line"></div><div class="line">        then:</div><div class="line">        at <span class="type">UserIndexPage</span></div><div class="line"></div><div class="line">        expect:</div><div class="line">        menu.hasClass(<span class="string">"active"</span>)</div><div class="line">        usersTable.find(<span class="string">"tbody tr"</span>).size() == <span class="number">3</span> <span class="comment">//check record count</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> "<span class="title">click</span> <span class="title">home</span> <span class="title">menu</span>"</span>() &#123;</div><div class="line">        when:</div><div class="line">        to <span class="type">UserIndexPage</span></div><div class="line"></div><div class="line">        then:</div><div class="line">        homeMenuButton.click(<span class="type">HomePage</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结以及个人的一点看法"><a href="#总结以及个人的一点看法" class="headerlink" title="总结以及个人的一点看法"></a>总结以及个人的一点看法</h2><p>无论是集成HtmlUnit还是Geb，他们都是基于Spring Test的MockMVC的，也就是容器内的测试，它们都不会启动Servlet容器，因而测试效率是很高的。由于它并没有启动Servlet容器，所以页面必须是通过模板引擎来渲染的，如果页面的渲染是通过JSP forward来实现，那么测试时无法进行的， 也正因如此，他们并不是完整E2E测试方案，虽然他们的脚本确实可以提供给E2E测试。</p>
<p>Spring Test和HtmlUnit或者Geb的集成， 就可以当做Functional Test来做，不要对Controller的依赖对象进行Mock。如果需要，Controller的集成测试可以另外进行，然后注入mock对象。这样进行的功能测试对比完整的E2E测试有个很大的优势在于，每个页面的测试都会重新加载ApplicaitonContext初始化数据库环境，因而不同的页面测试的数据是互不影响的。不需要像E2E测试，额外地进行一些数据的准备工作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Spring-Test&quot;&gt;&lt;a href=&quot;#Spring-Test&quot; class=&quot;headerlink&quot; title=&quot;Spring Test&quot;&gt;&lt;/a&gt;Spring Test&lt;/h2&gt;&lt;p&gt;Spring Test框架提供的MockMvc可用于实现Controller的集成测试。&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;figure class=&quot;highlight x86asm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;MockHttpServletRequestBuilder createMessage = post(&lt;span class=&quot;string&quot;&gt;&quot;/messages/&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;    .param&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;summary&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Spring Rocks&quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;    .param&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;text&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;In case you didn&#39;t know, Spring Rocks!&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;mockMvc.perform(createMessage)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;    .andExpect&lt;/span&gt;(status().is3xxRedirection())&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;    .andExpect&lt;/span&gt;(redirectedUrl(&lt;span class=&quot;string&quot;&gt;&quot;/messages/123&quot;&lt;/span&gt;))&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://yukinami.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="SpringFramework" scheme="http://yukinami.github.io/tags/SpringFramework/"/>
    
  </entry>
  
  <entry>
    <title>代码测试总结</title>
    <link href="http://yukinami.github.io/2016/05/28/%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yukinami.github.io/2016/05/28/代码测试总结/</id>
    <published>2016-05-28T09:44:10.000Z</published>
    <updated>2016-05-28T11:33:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>一些单元测试中设计的基本概念</p>
<ul>
<li>Stub 指的是以可控的方式对对象方法进行模拟，使其按照预期的行为返回结果或抛出异常等的过程。</li>
<li>Mock Object 整个对象都是模拟对象，所有方法在模拟之前进行调用都是空方法。</li>
<li>Spy Object 对真实对象的部分方法进行模拟，除了模拟的方法外调用的都是真实的方法。 </li>
</ul>
<a id="more"></a>
<p>单元测试的主体对象是方法，目的是测试目标方法的执行是否符合预期的行为，包括执行路径、返回值等。实施单元测试的主要目标是应用的POJOs。测试这些对象应该通过new来进行初始化，而不是通过从容器中获取的对象。目标方法中调用的过程中会调用其他的对象方法，可能基于下面的这些原因</p>
<ul>
<li>真实对象的行为是不确定的（例如，当前的时间或当前的温度）；</li>
<li>真实对象很难搭建起来；</li>
<li>真实对象的行为很难触发（例如，网络错误）；</li>
<li>真实对象速度很慢（例如，一个完整的数据库，在测试之前可能需要初始化）；</li>
<li>真实的对象是用户界面，或包括用户界面在内；</li>
<li>真实的对象使用了回调机制；</li>
<li>真实对象可能还不存在；</li>
<li>真实对象可能包含不能用作测试（而不是为实际工作）的信息和方法。</li>
</ul>
<p>不能够或者不应该使用真实的对象方法。使用Mock对象，可以避免其他方法执行结果对目标方法执行的干扰，同时能够更好的控制方法的执行路径。</p>
<p>实施单元测试的好处不仅仅在于它能保证代码的正确性，更大的好处在于它的高效，因为它是通过new初始化的，调用的对象也可以进行mock，并不依赖于难以控制的外部环境。另外的好处是可以间接地提高代码的品质要求，如果你想实施单元测试，那么你得要求你的类尽可能的是一个POJO，代码应该应有较好的分层结构以及松散的耦合，一段品质很差的代码要实施单元测试是非常苦难的。</p>
<h4 id="如何进行Mock"><a href="#如何进行Mock" class="headerlink" title="如何进行Mock"></a>如何进行Mock</h4><p>下面是基本的mock准则</p>
<ul>
<li>不要什么都mock</li>
<li>不要mock不是你的类</li>
<li>不要mock值对象</li>
</ul>
<p>针对大多数的mock框架，使用mock对象的步骤大致是一致的</p>
<ol>
<li>创建mock对象</li>
<li>录制需要mock的方法行为</li>
<li>调用mock对象</li>
<li>验证</li>
</ol>
<p>下面是<a href="http://mockito.org/" target="_blank" rel="external">Mocktio</a>的示例代码</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// you can mock concrete classes, not only interfaces</span></div><div class="line">LinkedList mockedList = mock(LinkedList.<span class="keyword">class</span>);</div><div class="line"></div><div class="line"><span class="comment">// stubbing appears before the actual execution</span></div><div class="line"><span class="keyword">when</span>(mockedList.<span class="keyword">get</span>(<span class="number">0</span>)).thenReturn(<span class="string">"first"</span>);</div><div class="line"></div><div class="line"><span class="comment">// the following prints "first"</span></div><div class="line">System.<span class="keyword">out</span>.println(mockedList.<span class="keyword">get</span>(<span class="number">0</span>));</div><div class="line"></div><div class="line"><span class="comment">// the following prints "null" because get(999) was not stubbed</span></div><div class="line">System.<span class="keyword">out</span>.println(mockedList.<span class="keyword">get</span>(<span class="number">999</span>));</div><div class="line"></div><div class="line"><span class="comment">// virify get(0) is called</span></div><div class="line">verify(mockedList.<span class="keyword">get</span>).<span class="keyword">get</span>(<span class="number">0</span>);</div></pre></td></tr></table></figure>
<h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p>集成测试主要针对是测试多个组件组合在一起工作的情况。 例如Repository接口和Spring Data JPA集成的情况下，生成的查询接口测试；Web框架和Controller集成的情况下，请求参数的绑定、转换、验证是否正常；和消息中间件集成时，消息的收发是否正常等等。</p>
<h3 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h3><p>功能测试有时候也叫E2E测试，功能测试以系统的功能点为测试对象。以Web应用为例，功能测试的主要应该是测试页面的功能是否正常，例如测试</p>
<ul>
<li>请求是否成功</li>
<li>重定向是否正确</li>
<li>用户是否成功授权</li>
<li>页面的元素是否正常显示</li>
<li>页面的表单的验证是否正确，提交后的跳转是否正确</li>
</ul>
<p>功能测试最常用的工具<a href="http://www.seleniumhq.org/" target="_blank" rel="external">Selenium</a>。当然有些框架也提供应用内的功能测试，例如Rails的Functional Test，但是这些测试不属于E2E测试的范畴，因为他们是基于容器内的测试，而不是完全独立的端到端的测试。</p>
<p>测试逻辑</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CreateMessagePage page = CreateMessagePage.to<span class="comment">(driver)</span>;</div><div class="line">ViewMessagePage viewMessagePage =</div><div class="line">    page.createMessage<span class="comment">(ViewMessagePage.class, expectedSummary, expectedText)</span>;</div><div class="line">    </div><div class="line">assertThat<span class="comment">(viewMessagePage.getMessage()</span>).isEqualTo<span class="comment">(expectedMessage)</span>;</div><div class="line">assertThat<span class="comment">(viewMessagePage.getSuccess()</span>).isEqualTo<span class="comment">("Successfully created a new message")</span>;</div></pre></td></tr></table></figure>
<h2 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h2><h3 id="Behavior-driven-development-BDD"><a href="#Behavior-driven-development-BDD" class="headerlink" title="Behavior-driven development(BDD)"></a>Behavior-driven development(BDD)</h3><p>行为驱动开发是一种敏捷软件开发的技术，它鼓励软件项目中的开发者、QA和非技术人员或商业参与者之间的协作。 BDD是一种开发方式，但是它和测试紧密相关。BDD用它的DSL来描述系统的功能的，测试用例则则相当于对功能描述一个实现。</p>
<h4 id="Cucumber"><a href="#Cucumber" class="headerlink" title="Cucumber"></a>Cucumber</h4><p><a href="https://cucumber.io/" target="_blank" rel="external">Cucumber</a>是一个BDD的框架，它支持各种语言的实现。</p>
<h5 id="业务描述"><a href="#业务描述" class="headerlink" title="业务描述"></a>业务描述</h5><p>Cucumber使用<a href="https://github.com/cucumber/cucumber/wiki/Gherkin" target="_blank" rel="external">Gherkin</a>语言来作为DSL来对业务规则进行描述，下面是一个<a href="https://github.com/cucumber/cucumber/wiki/Gherkin" target="_blank" rel="external">Gherkin</a>的文档</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Feature</span>: Refund item</div><div class="line"></div><div class="line"><span class="mipsasm"><span class="symbol">  Scenario:</span> <span class="keyword">Jeff </span>returns a faulty microwave</span></div><div class="line">    Given <span class="keyword">Jeff </span>has <span class="keyword">bought </span>a microwave for $<span class="number">100</span></div><div class="line">    <span class="keyword">And </span>he has a receipt</div><div class="line">    When he returns the microwave</div><div class="line">    Then <span class="keyword">Jeff </span><span class="keyword">should </span><span class="keyword">be </span>refunded $<span class="number">100</span></div></pre></td></tr></table></figure>
<p>一个Scenario指的是一个业务规则的演示、描述。其中包括Give、And、When、Then等多个Step。</p>
<p>上面的文档就是非技术人员或商业参与者需要做的，使用DSL语言对系统功能进行描述。</p>
<h5 id="步骤实现"><a href="#步骤实现" class="headerlink" title="步骤实现"></a>步骤实现</h5><p>开发人员则需要对上面的文档中的描述进行实现，调用实际的功能代码，以达到测试代码的目的。</p>
<p>例如，针对下面的Step</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Scenario: <span class="keyword">Some</span> cukes</div><div class="line">  Given I have <span class="number">48</span> cukes <span class="keyword">in</span> my belly</div></pre></td></tr></table></figure>
<p>进行实现</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Given</span>(<span class="string">"I have (\\d+) cukes in my belly"</span>)</div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">I_have_cukes_in_my_bellt</span><span class="params">(<span class="keyword">int</span> cukes)</span> </span>&#123;</div><div class="line">	System.out.format(<span class="string">"Cukes: %n\n"</span>, cukes)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现方法是应该调用实际的业务代码，对于Given来说，应该是类似<code>setUp</code>来初始化测试上下文环境的。</p>
<h2 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h2><p>下面主要介绍下各个平台中较为广泛的使用的测试框架</p>
<h3 id="Test-Runner"><a href="#Test-Runner" class="headerlink" title="Test Runner"></a>Test Runner</h3><p>Test Runner是用来启动测试，调用测试代码，反馈测试结果的。它本身可能作为一个测试框架还包括了断言、Mock等其他额外的功能</p>
<ul>
<li><a href="http://karma-runner.github.io/" target="_blank" rel="external">Karama</a> 它作为JS的Test Runner，仅负责测试的运行。它是一个Node.js的模块，能够在本地启动浏览器执行测试用例，并将测试结果输出到本地控制台。</li>
<li>Junit Java平台的测试框架，它是一个完整的测试框架，除了负责运行测试用例，它还包括测试方法定义，断言的书写等功能。</li>
<li><a href="https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/testing_with_xcode/chapters/01-introduction.html" target="_blank" rel="external">XCTest</a> 从Xcode5，使用XCtest作为OS X和iOS平台的完整测试框架。 </li>
</ul>
<h3 id="BDD"><a href="#BDD" class="headerlink" title="BDD"></a>BDD</h3><p>即便开发团队不使用完整的BDD框架进行开发，使用BDD风格的测试用例描述方式，仍然有诸多的有点，测试用例具有良好的可读性。</p>
<p>下面是一些BDD测试框架，其中一部分虽然是测试框架，但也创建拥有功能描述文档的功能</p>
<ul>
<li><a href="http://jasmine.github.io/edge/introduction.html" target="_blank" rel="external">Jasmine</a> 基于JS的完整BDD测试框架，包括断言、mock的功能。</li>
<li><a href="https://code.google.com/archive/p/spock/" target="_blank" rel="external">Spock</a> 基于Groovy的BDD测试框架，有用自己特有的断言方式，也支持使用groovy-test的断言。</li>
<li><a href="https://github.com/specta/specta" target="_blank" rel="external">Specta</a> 基于Object-C和Cocoa的BDD测试框架，它不提供断言、mock的功能。</li>
<li><a href="https://github.com/kiwi-bdd/Kiwi" target="_blank" rel="external">Kiwi</a> iOS平台的完整BDD测试框架，包括了断言、mock的功能。</li>
</ul>
<h3 id="Mock库"><a href="#Mock库" class="headerlink" title="Mock库"></a>Mock库</h3><ul>
<li><a href="http://jasmine.github.io/edge/introduction.html" target="_blank" rel="external">Jasmine</a> Jasmine包括了mock功能</li>
<li><a href="http://mockito.org/" target="_blank" rel="external">Mocktio</a> Java平台的著名的Mock的库</li>
<li><a href="https://github.com/jonreid/OCMockito" target="_blank" rel="external">OCMockito</a> Mocktio的OC版本</li>
</ul>
<p>除了针对对象方法的mock库，还有一些实现了类似mock功能的库。</p>
<ul>
<li>[OHHTTPStubs] iOS平台的HTTP请求的Stub库。它可以Stub所有通过NSURLConnection接口进行的请求，模拟数据的返回，模拟网速慢的情况的请求等。 除了可以用于更高效的测试外，还可以用于开发阶段，API等尚未完成时的接口模拟等。</li>
</ul>
<h3 id="断言-amp-匹配库"><a href="#断言-amp-匹配库" class="headerlink" title="断言&amp;匹配库"></a>断言&amp;匹配库</h3><p>匹配库本身并不是测试必要的一部分，但是有了匹配库可以让断言的书写更为简洁和高效</p>
<ul>
<li><a href="http://jasmine.github.io/edge/introduction.html" target="_blank" rel="external">Jasmine</a> Jasmine包括了断言的功能</li>
<li><a href="http://joel-costigliola.github.io/assertj/" target="_blank" rel="external">AssertJ</a> 具有fluent API的Java断言库</li>
<li><a href="https://code.google.com/archive/p/hamcrest/wikis/Tutorial.wiki" target="_blank" rel="external">Hamcrest</a> assertThat风格Java断言库，它同时是个匹配库，拥有很多非常实用的匹配器，能够和AssertJ集成</li>
<li><a href="https://github.com/specta/expecta" target="_blank" rel="external">Expecta</a> 基于Object-C和Cocoa的断言库，同时也是Specta的兄弟库</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;h3 id=&quot;单元测试&quot;&gt;&lt;a href=&quot;#单元测试&quot; class=&quot;headerlink&quot; title=&quot;单元测试&quot;&gt;&lt;/a&gt;单元测试&lt;/h3&gt;&lt;p&gt;一些单元测试中设计的基本概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Stub 指的是以可控的方式对对象方法进行模拟，使其按照预期的行为返回结果或抛出异常等的过程。&lt;/li&gt;
&lt;li&gt;Mock Object 整个对象都是模拟对象，所有方法在模拟之前进行调用都是空方法。&lt;/li&gt;
&lt;li&gt;Spy Object 对真实对象的部分方法进行模拟，除了模拟的方法外调用的都是真实的方法。 &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://yukinami.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>使用coveralls统计测试覆盖率</title>
    <link href="http://yukinami.github.io/2016/05/27/%E4%BD%BF%E7%94%A8coveralls%E7%BB%9F%E8%AE%A1%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87/"/>
    <id>http://yukinami.github.io/2016/05/27/使用coveralls统计测试覆盖率/</id>
    <published>2016-05-27T13:14:07.000Z</published>
    <updated>2016-05-27T13:49:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://coveralls.io/" target="_blank" rel="external">coveralls</a>可以持续跟踪代码的测试覆盖率。 为了让它能够跟踪到测试覆盖率，需要测试的时候生成覆盖率数据，并提供给coveralls service。</p>
<a id="more"></a>
<h2 id="生成测试覆盖率数据"><a href="#生成测试覆盖率数据" class="headerlink" title="生成测试覆盖率数据"></a>生成测试覆盖率数据</h2><p>jacoco和cobertura都可以用来统计代码的测试覆盖率，并且各自都有gradle和maven的插件。下面以gradle为例进行讨论。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">apply</span> plugin: <span class="string">"jacoco"</span></div></pre></td></tr></table></figure>
<p>通过上述配置启用jacoco插件。启用后，按照官方文档说法，如果同时启用了Java插件的话，那么任务jacocoTestReport将会被创建并且它依赖于test任务，但是实际运行的时候发现它并没有依赖于test任务</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-pseudo">:compileJava</span></div><div class="line"><span class="selector-pseudo">:compileGroovy</span></div><div class="line"><span class="selector-pseudo">:processResources</span></div><div class="line"><span class="selector-pseudo">:classes</span></div><div class="line"><span class="selector-pseudo">:jacocoTestReport</span> <span class="selector-tag">SKIPPED</span></div></pre></td></tr></table></figure>
<p>并且直接运行的话，它会被跳过。</p>
<p>jacocoTestReport任务是用来发布jacoco报告的，它依赖于jacoco的测试覆盖率数据文件<code>text.exec</code>。 如果启用了jacoco插件，测试覆盖率数据文件会在test任务执行的时候生成，位于<code>build/jacoco</code>目录下。</p>
<p>在生成这个文件的前提下，执行jacocoTestReport任务，就会在<code>build/reports/tests/jacoco</code>目录生成报告，默认生成HTML格式的报告。</p>
<h2 id="上传coveralls"><a href="#上传coveralls" class="headerlink" title="上传coveralls"></a>上传coveralls</h2><p>jacoco生成的报告需要上传给coveralls才能显示。Maven的话通过<a href="https://github.com/trautonen/coveralls-maven-plugin" target="_blank" rel="external">coveralls-maven-plugin</a>可以实现，gradle则使用插件<a href="https://github.com/kt3k/coveralls-gradle-plugin" target="_blank" rel="external">coveralls-gradle-plugin</a>。</p>
<p>以<a href="https://github.com/kt3k/coveralls-gradle-plugin" target="_blank" rel="external">coveralls-gradle-plugin</a>为例</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="section">plugins</span> &#123;</div><div class="line">    <span class="attribute">id</span> <span class="string">'jacoco'</span></div><div class="line">    id <span class="string">'com.github.kt3k.coveralls'</span> version <span class="string">'2.6.3'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它插件依赖于jacoco生成的XML报告，因此需要配置jacoco</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">jacocoTestReport &#123;</div><div class="line">	reports &#123;</div><div class="line">		xml<span class="selector-class">.enabled</span> = true</div><div class="line">		<span class="selector-tag">html</span><span class="selector-class">.enabled</span> = true</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="CI服务器"><a href="#CI服务器" class="headerlink" title="CI服务器"></a>CI服务器</h2><p>最后coveralls需要配合一个CI服务器，持续地对代码的测试覆盖率进行统计，支持<a href="https://travis-ci.org/" target="_blank" rel="external">Travis CI</a>、Jenkins等多种CI服务器。</p>
<p>以Travis为例，需要在构建的最后执行上面的提到的，生成测试覆盖率报告并上传的任务</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">after_success:</div><div class="line">-<span class="ruby"> ./gradlew jacocoTestReport coveralls</span></div><div class="line">`</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://coveralls.io/&quot;&gt;coveralls&lt;/a&gt;可以持续跟踪代码的测试覆盖率。 为了让它能够跟踪到测试覆盖率，需要测试的时候生成覆盖率数据，并提供给coveralls service。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CI" scheme="http://yukinami.github.io/tags/CI/"/>
    
      <category term="测试" scheme="http://yukinami.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>用Spring data rest开发基于HATEOAS的API</title>
    <link href="http://yukinami.github.io/2016/05/22/%E7%94%A8Spring-data-rest%E5%BC%80%E5%8F%91%E5%9F%BA%E4%BA%8EHATEOAS%E7%9A%84API/"/>
    <id>http://yukinami.github.io/2016/05/22/用Spring-data-rest开发基于HATEOAS的API/</id>
    <published>2016-05-22T02:17:03.000Z</published>
    <updated>2016-05-22T07:14:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>首先，HATEOAS (Hypermedia as the Engine of Application State) 是REST应用架构的一个约束。一个<em>hypermedia-driven</em>的站点通过响应中的超媒体链接动态地提供了导航到站点的REST接口的信息。</p>
<p>下面是一个基于HATEOAS的响应</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"name"</span>: <span class="string">"Alice"</span>,</div><div class="line">    <span class="attr">"links"</span>: [ &#123;</div><div class="line">        <span class="attr">"rel"</span>: <span class="string">"self"</span>,</div><div class="line">        <span class="attr">"href"</span>: <span class="string">"http://localhost:8080/customer/1"</span></div><div class="line">    &#125; ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>Spring使用HAL作为HATEOAS的实现。</p>
<p>Spring Data Rest是Spring Data的子项目，那么该项目是为了实现类似Spring Data JPA的统一数据访问层接口的目的。 实际情况，只要定义了Spring Data的标准Repository接口，那么Spring Data Rest便会为你提供一套标准的基于HTEOAS的REST接口。 如果你的应用架构是基于DDD的，那么对Spring Data Rest接口接入会显得非常友好。</p>
<h2 id="Spring对于HAL的实现"><a href="#Spring对于HAL的实现" class="headerlink" title="Spring对于HAL的实现"></a>Spring对于HAL的实现</h2><p>使用Spring Data Rest时，<code>RepositoryRestMvcConfiguration</code>中注册的jacksonHttpMessageConverter是负责把ResourceSupport子类对象渲染成HAL格式的JSON字符串的。通常情况下对于请求的Media Type是<code>application/hal+json</code>时，才会用这个converter进行转化。<code>useHalAsDefaultJsonMediaType</code>可以控制，当请求JSON media type时，是否默认使用HAL。这个参数的默认值是true，也就是说如果客户端请求的是普通的application/json，对于ResourceSupport子类对象依然可以返回HAL格式的JSON。 另外如果请求时不指定Media Type的，那么Spring Data Rest的defaultMediaType配置将会生效，默认值为<code>application/hal+json</code>。</p>
<p>下面是注册jacksonHttpMessageConverter的相关代码</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">@<span class="function">Bean</span></div><div class="line"><span class="keyword">public</span> TypeConstrainedMappingJackson2HttpMessageConverter <span class="title">halJacksonHttpMessageConverter</span>(<span class="params"></span>) &#123;</div><div class="line"></div><div class="line">	ArrayList&lt;MediaType&gt; mediaTypes = <span class="keyword">new</span> ArrayList&lt;MediaType&gt;();</div><div class="line">	mediaTypes.<span class="keyword">add</span>(MediaTypes.HAL_JSON);</div><div class="line"></div><div class="line">	<span class="comment">// Enable returning HAL if application/json is asked if it's configured to be the default type</span></div><div class="line">	<span class="keyword">if</span> (config().useHalAsDefaultJsonMediaType()) &#123;</div><div class="line">		mediaTypes.<span class="keyword">add</span>(MediaType.APPLICATION_JSON);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> order = config().useHalAsDefaultJsonMediaType() ? Ordered.LOWEST_PRECEDENCE - <span class="number">10</span></div><div class="line">			: Ordered.LOWEST_PRECEDENCE - <span class="number">1</span>;</div><div class="line"></div><div class="line">	TypeConstrainedMappingJackson2HttpMessageConverter converter = <span class="keyword">new</span> ResourceSupportHttpMessageConverter(order);</div><div class="line">	converter.setObjectMapper(halObjectMapper());</div><div class="line">	converter.setSupportedMediaTypes(mediaTypes);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> converter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果没有使用Spring Data Rest而是单独使用Spring HATOAS的话，这个jacksonHttpMessageConverter将由<code>HypermediaSupportBeanDefinitionRegistrar</code>来注册。 Spring Boot的情况，<code>HypermediaAutoConfiguration</code>会导入<code>HypermediaHttpMessageConverterConfiguration</code>来针对<code>spring.hateoas.use-hal-as-default-json-media-type</code>配置来支持<code>application/json</code>。</p>
<p><a href="https://github.com/spring-projects/spring-boot/commit/c55900b43398764d924a485b1244bfba8444eab9" target="_blank" rel="external">这里</a>是关于Spring HATEOAS和Spring Data Rest的自动配置的一些说明。在这次修复之前，由于<code>RepositoryRestMvcAutoConfiguration</code>会早于<code>JacksonAutoConfiguration</code>运行，导致<code>JacksonAutoConfiguration</code>被间接的关闭，没有注册@Primary的ObjectMapper，从而导致注入到<code>JacksonHttpMessageConvertersConfiguration</code>的ObjectMapper是一个被HAL全局污染的ObjectMapper。</p>
<h2 id="使用中可能会遇到的一些问题"><a href="#使用中可能会遇到的一些问题" class="headerlink" title="使用中可能会遇到的一些问题"></a>使用中可能会遇到的一些问题</h2><p>下面的问题都是针对Spring Data Rest配合Spring Data JPA一起使用，并使用Hibernate作为JPA的Vendor。</p>
<h3 id="自定义方法实现"><a href="#自定义方法实现" class="headerlink" title="自定义方法实现"></a>自定义方法实现</h3><p>有些时候，我们希望覆盖Spring Data Rest的标准实现，或者实现一些额外的接口，就需要自定义处理方法。</p>
<ul>
<li>自定义的Controller需要使用@RepositoryRestController注解，这样才能让Spring Data Rest处理。</li>
<li><p>URL的路径必须属于某个Repository的资源路径，下面是<code>RepositoryRestHandlerMapping</code>的一段处理逻辑</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@Override</span></div><div class="line"><span class="keyword">protected</span> <span class="function">HandlerMethod <span class="title">lookupHandlerMethod</span><span class="params">(String lookupPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">	HandlerMethod handlerMethod = <span class="keyword">super</span>.lookupHandlerMethod(lookupPath, request);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (handlerMethod == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	String repositoryLookupPath = <span class="keyword">new</span> BaseUri(configuration.getBaseUri()).getRepositoryLookupPath(lookupPath);</div><div class="line"></div><div class="line">	<span class="comment">// Repository root resource</span></div><div class="line">	<span class="keyword">if</span> (!StringUtils.hasText(repositoryLookupPath)) &#123;</div><div class="line">		<span class="keyword">return</span> handlerMethod;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> mappings.exportsTopLevelResourceFor(getRepositoryBasePath(repositoryLookupPath)) ? handlerMethod : <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>注入PersistentEntityResourceAssembler来装配符合HATEOAS的响应JSON对象</p>
</li>
</ul>
<h3 id="API-version的实现"><a href="#API-version的实现" class="headerlink" title="API version的实现"></a>API version的实现</h3><p>通过上面Spring对HAL的实现中提到的，如果我们想通过请求<code>application/vnd.xxx.vxx+hal+json</code>来实现版本的话，jacksonHttpMessageConverter是不会起作用的，因为它只会严格匹配<code>application/json</code>和<code>application/hal+json</code>。因此那么我们需要扩展匹配的Media Type来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="meta">@DependsOn</span>(<span class="string">"halMessageConverterSupportedMediaTypeCustomizer"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> HalVersionMessageConverterSupportedMediaTypesCustomizer <span class="title">registerCustomMediaType</span><span class="params">(@Qualifier(<span class="string">"halJacksonHttpMessageConverter"</span>)</span> TypeConstrainedMappingJackson2HttpMessageConverter halJacksonHttpMessageConverter) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HalVersionMessageConverterSupportedMediaTypesCustomizer();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">HalVersionMessageConverterSupportedMediaTypesCustomizer</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HAL_JACKSON_HTTP_MESSAGE_CONVERTER_BEAN_NAME = <span class="string">"halJacksonHttpMessageConverter"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> BeanFactory beanFactory;</div><div class="line"></div><div class="line">    <span class="meta">@PostConstruct</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customizedSupportedMediaTypes</span><span class="params">()</span> </span>&#123;</div><div class="line">        TypeConstrainedMappingJackson2HttpMessageConverter halJacksonHttpMessageConverter = beanFactory.getBean(HAL_JACKSON_HTTP_MESSAGE_CONVERTER_BEAN_NAME, TypeConstrainedMappingJackson2HttpMessageConverter.class);</div><div class="line">        List&lt;MediaType&gt; supportedMediaTypes = <span class="keyword">new</span> ArrayList&lt;&gt;(halJacksonHttpMessageConverter.getSupportedMediaTypes());</div><div class="line">        supportedMediaTypes.add(<span class="keyword">new</span> MediaType(<span class="string">"application"</span>, <span class="string">"*+hal+json"</span>));</div><div class="line">        halJacksonHttpMessageConverter.setSupportedMediaTypes(supportedMediaTypes);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>必须在<code>HalMessageConverterSupportedMediaTypesCustomizer</code>之后执行，否则会被其覆盖supportedMediaTypes</p>
<h3 id="没有定义Repository的实体的关联的问题"><a href="#没有定义Repository的实体的关联的问题" class="headerlink" title="没有定义Repository的实体的关联的问题"></a>没有定义Repository的实体的关联的问题</h3><p>如果实体A包含一个到实体B的关联，查询实体A时，返回的结果会根据实体B的Repository是否存在会有不同。</p>
<ul>
<li>存在B的Repository  那么A到B关联会被处理成link，而返回的A的对象中并不会直接包含B的对象</li>
<li>不存在B的Repository 那么由于不存在B的资源的链接，自然不会生成link，并且A对象中会直接包含B对象。 如果在查询A对象时B关联是lazy的，那么这里就会产生额外的查询。所以需要注意，如果包含的关联中是实体不存在Repository时，查询时最好就把这些关联对象fetch出来，否则会对性能产生一定的影响。</li>
<li>另外不能定义class级别的@RequestMapping，否则路径会被注册两遍。因为标准的<code>RequestMappingHandlerMapping</code>是这样判断是否要注册映射的<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> @Override</div><div class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> isHandler(<span class="keyword">Class</span>&lt;?&gt; beanType) &#123;</div><div class="line">	<span class="keyword">return</span> ((AnnotationUtils.findAnnotation(beanType, Controller.<span class="keyword">class</span>) != <span class="keyword">null</span>) ||</div><div class="line">			(AnnotationUtils.findAnnotation(beanType, RequestMapping.<span class="keyword">class</span>) != <span class="keyword">null</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Excerpt不起作用"><a href="#Excerpt不起作用" class="headerlink" title="Excerpt不起作用"></a>Excerpt不起作用</h3><p>官方文档中提到，Excerpt只针对单个资源的请求有效，如果资源是集合，那么Excerpt是不会生效的</p>
<blockquote>
<p>Excerpt projections are NOT applied to single resources automatically. They have to be applied deliberately. Excerpt projections are meant to provide a default preview of collection data, but not when fetching individual resources. </p>
</blockquote>
<p>这是框架中的<code>RepositoryEntityController</code>处理的逻辑。<code>PersistentEntityResourceAssembler</code>有<code>toFullResource</code>和<code>toResource</code>方法，前者会忽略Excerpt。<code>RepositoryEntityController</code>针对集合的情况会调用<code>toFullResource</code>，因而Excerpt是不起作用的。</p>
<h3 id="定义了Excerpt的实体的关联对象会产生额外的查询的问题"><a href="#定义了Excerpt的实体的关联对象会产生额外的查询的问题" class="headerlink" title="定义了Excerpt的实体的关联对象会产生额外的查询的问题"></a>定义了Excerpt的实体的关联对象会产生额外的查询的问题</h3><p>如果实体A包含一个到实体B的关联，实体B的Repository定义了Excerpt的话，那么虽然最终的返回的对象A中并不包含对象B，只是包含了一个link。但是对象的B的值仍然会被获取。在JPA中懒加载的情况下，这个应该不被加载的关联，就会被触发fetch，而产生额外的查询，对性能产生影响。</p>
<p>下面是<code>PersistentEntityResourceAssember#doWithAssociation</code>中相关的代码</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public <span class="keyword">void</span> doWithAssociation(Association&lt;? extends PersistentProperty&lt;?&gt;&gt; association) &#123;</div><div class="line"></div><div class="line">	PersistentProperty&lt;?&gt; <span class="keyword">property</span><span class="string"> </span>= association.getInverse();</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (!associationLinks.isLinkableAssociation(<span class="keyword">property</span><span class="string">)) &#123;</span></div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (!projector.hasExcerptProjection(<span class="keyword">property</span><span class="string">.getActualType())) &#123;</span></div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="built_in">Object</span> value = accessor.getProperty(association.getInverse());</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	……</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果实体会被关联的话，所以不要轻易定义Excerpt。</p>
<h3 id="如何指定多个Projection"><a href="#如何指定多个Projection" class="headerlink" title="如何指定多个Projection"></a>如何指定多个Projection</h3><p>如果返回的一个列中包含A和B两个实体，针对这两个实体都想指定Projection怎么办。虽然URL中只能指定一个projection参数，但是projection是可以重名的，只要他们对应的types即projection针对的实体不一样即可。</p>
<h2 id="BasePathAwareController注解的Controller中懒加载出错"><a href="#BasePathAwareController注解的Controller中懒加载出错" class="headerlink" title="@BasePathAwareController注解的Controller中懒加载出错"></a>@BasePathAwareController注解的Controller中懒加载出错</h2><p><code>RepositoryRestHandlerMapping</code>中通过<code>JpaHelper</code>在interceptor中添加了<code>OpenEntityManagerInViewInterceptor</code>，但是<code>BasePathAwareHandlerMapping</code>并没有这个拦截器。</p>
<p>通过</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line">public MappedInterceptor basePathAwareOpenEntityManagerInViewInterceptor(EntityManagerFactory <span class="keyword">factory</span>) &#123;</div><div class="line">    OpenEntityManagerInViewInterceptor omivi = <span class="keyword">new</span> OpenEntityManagerInViewInterceptor();</div><div class="line">    omivi.setEntityManagerFactory(<span class="keyword">factory</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MappedInterceptor(<span class="keyword">new</span> <span class="built_in">String</span>[]&#123;<span class="string">"/api/**"</span>&#125;, omivi);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即可在所有的HandlerMapping中添加拦截器，可能和<code>RepositoryRestHandlerMapping</code>已经存在的会有点重复，但是并没有什么副作用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;首先，HATEOAS (Hypermedia as the Engine of Application State) 是REST应用架构的一个约束。一个&lt;em&gt;hypermedia-driven&lt;/em&gt;的站点通过响应中的超媒体链接动态地提供了导航到站点的REST接口的信息。&lt;/p&gt;
&lt;p&gt;下面是一个基于HATEOAS的响应&lt;/p&gt;
&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Alice&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;&quot;links&quot;&lt;/span&gt;: [ &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;&quot;rel&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;self&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;attr&quot;&gt;&quot;href&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;http://localhost:8080/customer/1&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; ]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="API" scheme="http://yukinami.github.io/tags/API/"/>
    
      <category term="Sring Data Rest" scheme="http://yukinami.github.io/tags/Sring-Data-Rest/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP的实现</title>
    <link href="http://yukinami.github.io/2016/05/21/Spring-AOP%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yukinami.github.io/2016/05/21/Spring-AOP的实现/</id>
    <published>2016-05-21T09:43:51.000Z</published>
    <updated>2016-05-21T11:18:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>Aspect 切面，指的是切分多个类的模块化的关注点，包括Pointcut或Advice</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotVeryUsefulAspect</span> &#123;</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<ul>
<li>Join point 程序的执行点， 可用于插入代码 （在Spring里面指的是方法的执行）</li>
<li><p>Advice 对特定的Join point执行的动作</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Before</span>(<span class="string">"com.xyz.myapp.SystemArchitecture.dataAccessOperation()"</span>)</div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">// ...</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Pointcut 匹配Join point的断言</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* transfer(..))"</span>)<span class="comment">// the pointcut expression</span></div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">anyOldTransfer</span><span class="params">()</span> </span>&#123;&#125;<span class="comment">// the pointcut signature</span></div></pre></td></tr></table></figure>
</li>
<li><p>Introduction 定义额外的方法或字段</p>
</li>
<li>Target Object 被一个或多个切面通知的目标对象</li>
<li>AOP proxy 由AOP框架创建的代理对象</li>
<li>Weaving 连接切面和应用对象来实现切面的功能</li>
</ul>
<p>AOP的实现关键在于AOP代理的创建。代理对象可以分为静态代理和动态代理。</p>
<ul>
<li>静态代理的实现  通过织入来创建静态的代理对象，AspectJ的实现就是这种方式</li>
<li>动态代理的实现  通过JDK动态代理或者CGlib来创建动态的代理对象，Spring AOP的实现就是这种方式</li>
</ul>
<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><p>Spring AOP采用的是动态代理的实现。配置AOP方式可以采用AspectJ的注解或者基于Spring的Schema的XML配置。</p>
<h3 id="基于AspectJ的AOP配置"><a href="#基于AspectJ的AOP配置" class="headerlink" title="基于AspectJ的AOP配置"></a>基于AspectJ的AOP配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentOperationExecutor</span> <span class="keyword">implements</span> <span class="title">Ordered</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_RETRIES = <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxRetries = DEFAULT_MAX_RETRIES;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> order = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxRetries</span><span class="params">(<span class="keyword">int</span> maxRetries)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.maxRetries = maxRetries;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.order;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrder</span><span class="params">(<span class="keyword">int</span> order)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.order = order;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Around</span>(<span class="string">"com.xyz.myapp.SystemArchitecture.businessService()"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doConcurrentOperation</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">int</span> numAttempts = <span class="number">0</span>;</div><div class="line">        PessimisticLockingFailureException lockFailureException;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            numAttempts++;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">return</span> pjp.proceed();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">catch</span>(PessimisticLockingFailureException ex) &#123;</div><div class="line">                lockFailureException = ex;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">while</span>(numAttempts &lt;= <span class="keyword">this</span>.maxRetries);</div><div class="line">        <span class="keyword">throw</span> lockFailureException;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;aop:aspectj-autoproxy/&gt;</div><div class="line"></div><div class="line">&lt;bean <span class="built_in">id</span>=<span class="string">"concurrentOperationExecutor"</span> <span class="built_in">class</span>=<span class="string">"com.xyz.myapp.service.impl.ConcurrentOperationExecutor"</span>&gt;</div><div class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"maxRetries"</span> value=<span class="string">"3"</span>/&gt;</div><div class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"order"</span> value=<span class="string">"100"</span>/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<h3 id="基于Schema的AOP配置"><a href="#基于Schema的AOP配置" class="headerlink" title="基于Schema的AOP配置"></a>基于Schema的AOP配置</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;aop:config&gt;</div><div class="line"></div><div class="line">    &lt;aop:aspect <span class="built_in">id</span>=<span class="string">"concurrentOperationRetry"</span> <span class="keyword">ref</span>=<span class="string">"concurrentOperationExecutor"</span>&gt;</div><div class="line"></div><div class="line">        &lt;aop:pointcut <span class="built_in">id</span>=<span class="string">"idempotentOperation"</span></div><div class="line">            expression=<span class="string">"execution(* com.xyz.myapp.service.*.*(..))"</span>/&gt;</div><div class="line"></div><div class="line">        &lt;aop:<span class="keyword">around</span></div><div class="line">            pointcut-<span class="keyword">ref</span>=<span class="string">"idempotentOperation"</span></div><div class="line">            method=<span class="string">"doConcurrentOperation"</span>/&gt;</div><div class="line"></div><div class="line">    &lt;/aop:aspect&gt;</div><div class="line"></div><div class="line">&lt;/aop:config&gt;</div><div class="line"></div><div class="line">&lt;bean <span class="built_in">id</span>=<span class="string">"concurrentOperationExecutor"</span></div><div class="line">    <span class="built_in">class</span>=<span class="string">"com.xyz.myapp.service.impl.ConcurrentOperationExecutor"</span>&gt;</div><div class="line">        &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"maxRetries"</span> value=<span class="string">"3"</span>/&gt;</div><div class="line">        &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"order"</span> value=<span class="string">"100"</span>/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<h3 id="Spring中使用AspectJ"><a href="#Spring中使用AspectJ" class="headerlink" title="Spring中使用AspectJ"></a>Spring中使用AspectJ</h3><p>AspectJ的通过静态代理来实现AOP的织入的。根据织入时机的不同，又分为编译时织入和类加载时织入（LTW）。Spring对AspjectJ的LTW进行了一定的增强，使得LTW能够针对于单个ClassLoader而不是整个JVM。</p>
<p>下面是个例子</p>
<p>首先定义AOP</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> foo;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</div><div class="line"><span class="keyword">import</span> org.aspectj.lang.<span class="keyword">annotation</span>.Aspect;</div><div class="line"><span class="keyword">import</span> org.aspectj.lang.<span class="keyword">annotation</span>.Around;</div><div class="line"><span class="keyword">import</span> org.aspectj.lang.<span class="keyword">annotation</span>.Pointcut;</div><div class="line"><span class="keyword">import</span> org.springframework.util.StopWatch;</div><div class="line"><span class="keyword">import</span> org.springframework.core.<span class="keyword">annotation</span>.Order;</div><div class="line"></div><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProfilingAspect</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Around(<span class="meta-string">"methodsToBeProfiled()"</span>)</span></div><div class="line">    <span class="keyword">public</span> Object profile(ProceedingJoinPoint pjp) throws Throwable &#123;</div><div class="line">        StopWatch sw = new StopWatch(getClass().getSimpleName());</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            sw.start(pjp.getSignature().getName());</div><div class="line">            <span class="keyword">return</span> pjp.proceed();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            sw.stop();</div><div class="line">            System.<span class="keyword">out</span>.println(sw.prettyPrint());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Pointcut(<span class="meta-string">"execution(public * foo..*.*(..))"</span>)</span></div><div class="line">    <span class="keyword">public</span> void methodsToBeProfiled()&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后定义需要织入的对象</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE aspectj PUBLIC "-//AspectJ//DTD//EN" "http://www.eclipse.org/aspectj/dtd/aspectj.dtd"&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">aspectj</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">weaver</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- only weave classes in our application-specific packages --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">within</span>=<span class="string">"foo.*"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">weaver</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">aspects</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- weave in just this aspect --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"foo.ProfilingAspect"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">aspects</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">aspectj</span>&gt;</span></div></pre></td></tr></table></figure>
<p>最后启用Spring的LTW</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></div><div class="line">        http://www.springframework.org/schema/beans</div><div class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">        http://www.springframework.org/schema/context</div><div class="line">        http://www.springframework.org/schema/context/spring-context.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- a service object; we will be profiling its methods --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"entitlementCalculationService"</span></span></div><div class="line">            <span class="attr">class</span>=<span class="string">"foo.StubEntitlementCalculationService"</span>/&gt;</div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- this switches on the load-time weaving --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">context:load-time-weaver</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Aspect 切面，指的是切分多个类的模块化的关注点，包括Pointcut或Advice&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Aspect&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;NotVeryUsefulAspect&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://yukinami.github.io/tags/Spring/"/>
    
      <category term="AOP" scheme="http://yukinami.github.io/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate使用outer join fetch集合时返回重复的结果</title>
    <link href="http://yukinami.github.io/2016/05/21/Hibernate%E4%BD%BF%E7%94%A8outer%20join%20fetch%E9%9B%86%E5%90%88%E6%97%B6%E8%BF%94%E5%9B%9E%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E6%9E%9C/"/>
    <id>http://yukinami.github.io/2016/05/21/Hibernate使用outer join fetch集合时返回重复的结果/</id>
    <published>2016-05-21T09:00:37.000Z</published>
    <updated>2016-05-21T09:17:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果我们有一个订单关联三个订单项，当进行下面的查询时</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List result = session.createQuery("<span class="keyword">select</span> o <span class="keyword">from</span> <span class="keyword">Order</span> o <span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">fetch</span> o.lineItems<span class="string">").list();</span></div></pre></td></tr></table></figure>
<p>返回的结果集会是三个一样的订单对象，分别包含了三个订单项。</p>
<a id="more"></a>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>首先在SQL层面LEFT JOIN会以左表为驱动表去关联从表的中的所有记录。以上面的的订单为例，就会返回三条纪录。而Hibernate默认会保留所有的驱动表中的记录，多余的两条记录会引用同一条订单记录。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List result = session.createQuery("<span class="keyword">select</span> o <span class="keyword">from</span> <span class="keyword">Order</span> o <span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">fetch</span> o.lineItems<span class="string">")  </span></div><div class="line">                      .setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY) // Yes, really!  </div><div class="line">                      .list();</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List result = session.createQuery("<span class="keyword">select</span> <span class="keyword">distinct</span> o <span class="keyword">from</span> <span class="keyword">Order</span> o <span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">fetch</span> o.lineItems<span class="string">").list();</span></div></pre></td></tr></table></figure>
<p>后者的意义和SQL的distinct并不一样，这里它就是DISTINCT_ROOT_ENTITY result transformer的缩写。</p>
<p><a href="https://developer.jboss.org/wiki/HibernateFAQ-AdvancedProblems#jive_content_id_Hibernate_does_not_return_distinct_results_for_a_query_with_outer_join_fetching_enabled_for_a_collection_even_if_I_use_the_distinct_keyword" target="_blank" rel="external">https://developer.jboss.org/wiki/HibernateFAQ-AdvancedProblems#jive_content_id_Hibernate_does_not_return_distinct_results_for_a_query_with_outer_join_fetching_enabled_for_a_collection_even_if_I_use_the_distinct_keyword</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;如果我们有一个订单关联三个订单项，当进行下面的查询时&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;List result = session.createQuery(&quot;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; o &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;Order&lt;/span&gt; o &lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;join&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;fetch&lt;/span&gt; o.lineItems&lt;span class=&quot;string&quot;&gt;&quot;).list();&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;返回的结果集会是三个一样的订单对象，分别包含了三个订单项。&lt;/p&gt;
    
    </summary>
    
    
      <category term="经验错误" scheme="http://yukinami.github.io/tags/%E7%BB%8F%E9%AA%8C%E9%94%99%E8%AF%AF/"/>
    
      <category term="Hibernate" scheme="http://yukinami.github.io/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Jackson转换TimeStamp时空字串的问题</title>
    <link href="http://yukinami.github.io/2016/05/21/Jackson%E8%BD%AC%E6%8D%A2TimeStamp%E6%97%B6%E7%A9%BA%E5%AD%97%E4%B8%B2%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yukinami.github.io/2016/05/21/Jackson转换TimeStamp时空字串的问题/</id>
    <published>2016-05-21T07:45:59.000Z</published>
    <updated>2016-05-21T08:17:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当使用Jackson进行json数据转换时，如果目标字段类型为TimeStamp并且要转换的值为空字串时会报空指针错误。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>下面是Timestamp反序列化器的代码</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public static <span class="class"><span class="keyword">class</span> <span class="title">TimestampDeserializer</span> <span class="keyword">extends</span> <span class="title">DateBasedDeserializer&lt;Timestamp&gt;</span></span></div><div class="line">&#123;</div><div class="line">    public <span class="type">TimestampDeserializer</span>() &#123; <span class="keyword">super</span>(<span class="type">Timestamp</span>.<span class="keyword">class</span>); &#125;</div><div class="line">    public <span class="type">TimestampDeserializer</span>(<span class="type">TimestampDeserializer</span> src, <span class="type">DateFormat</span> df, <span class="type">String</span> formatString) &#123;</div><div class="line">        <span class="keyword">super</span>(src, df, formatString);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> <span class="type">TimestampDeserializer</span> withDateFormat(<span class="type">DateFormat</span> df, <span class="type">String</span> formatString) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">TimestampDeserializer</span>(<span class="keyword">this</span>, df, formatString);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    public java.sql.<span class="type">Timestamp</span> deserialize(<span class="type">JsonParser</span> jp, <span class="type">DeserializationContext</span> ctxt) <span class="keyword">throws</span> <span class="type">IOException</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Timestamp</span>(_parseDate(jp, ctxt).getTime());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过<code>_parseDate</code>方法转换为Date后，并没有判断是否转换成功而直接调用了getTime方法。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>添加一个自定义的TimeStamp的Deserializer，然后通过SimpleModule来注册到ObjectMapper中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;当使用Jackson进行json数据转换时，如果目标字段类型为TimeStamp并且要转换的值为空字串时会报空指针错误。&lt;/p&gt;
&lt;h2 i
    
    </summary>
    
    
      <category term="经验错误" scheme="http://yukinami.github.io/tags/%E7%BB%8F%E9%AA%8C%E9%94%99%E8%AF%AF/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate one-to-one 懒加载的问题</title>
    <link href="http://yukinami.github.io/2016/05/21/Hibernate-one-to-one-%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yukinami.github.io/2016/05/21/Hibernate-one-to-one-懒加载的问题/</id>
    <published>2016-05-21T06:24:29.000Z</published>
    <updated>2016-05-21T09:28:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Hibernate在使用OneToOne的反向关联或者使用主键关联（PrimaryKeyJoinColumn）时，会出来懒加载不起的作用的情况。究其原因，Hibernate的能够进行懒加载的前提是返回的关联对象是个代理对象。如果Hibernate不能确定关联的对象是否为空，那么他们不能直接返回代理对象，因为代理对象本身就是不为空的，它不得不去检查关联对象是否存在。但是用SELECT语句去检查存在性，还不如索性直接把查询结果返回，这也就导致了懒加载的失效。</p>
<a id="more"></a>
<p>上面的两种情况都是无法确定关联对象是否存在的</p>
<ul>
<li>反向关联  由于关联的外键并不存在于当前表，而是在关联表，必须把当前记录的主键作为条件去关联表的外键中去匹配才能确定关联对象是否存在</li>
<li>主键关联  由于关联的对象表的主键是使用的当前表的主键，单单查看当前表也无法确定关联对象的存在性</li>
</ul>
<p>所以也就导致这两种情况下的关联属性的懒加载是无法生效的。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h2 id="强制存在"><a href="#强制存在" class="headerlink" title="强制存在"></a>强制存在</h2><p>如果在映射文件中就明确定义出来关联对象不可能为空，那么Hibernate就没有必要去检查它的存在性，直接返回代理对象即可。 当前前提是业务的角度来说关联对象确实不可能为空。</p>
<h2 id="使用OneToMany来替代OneToOne"><a href="#使用OneToMany来替代OneToOne" class="headerlink" title="使用OneToMany来替代OneToOne"></a>使用OneToMany来替代OneToOne</h2><p>使用假的OneToMany来替代OneToOne，实际使用的时候始终取集合的第一个元素。因为Many端永远不会返回空，最多返回空集合。但是这个方式会对JPQL/HQL产生一定的影响</p>
<h2 id="使用字节码织入"><a href="#使用字节码织入" class="headerlink" title="使用字节码织入"></a>使用字节码织入</h2><p>不使用代理对象，而是使用字节码织入，最终调用关联对象的任何方法时才会触发懒加载。对于字节码的织入有编译时织入和运行时织入两种方式。编译时织入可以通过Hibernate提供的ant工具来实现。运行时织入则依赖的JavaEE环境或者使用Spring的运行时织入技术。</p>
<p>无论哪种情况，最终都需要使用@LazyToOne(LazyToOneOption.NO_PROXY) 注解来显示的告诉框架不适用代理对象，以及把Hibernate的<code>hibernate.ejb.use_class_enhancer</code>参数设置为true。</p>
<h3 id="启用Spring’s-LTW"><a href="#启用Spring’s-LTW" class="headerlink" title="启用Spring’s LTW"></a>启用Spring’s LTW</h3><p>Spring的LTW的核心组件是<code>LoadTimeWeaver</code>接口，<code>LoadTimeWeaver</code>的职责是负责在运行时添加一个和多个<code>java.lang.instrument.ClassFileTransformers</code>到<code>ClassLoader</code>中。</p>
<p>要启用Spring的LTW支持，首先需要配置<code>LoadTimeWeaver</code></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@Configuration</span></div><div class="line"><span class="variable">@EnableLoadTimeWeaving</span></div><div class="line">public class AppConfig &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">`</div></pre></td></tr></table></figure>
<p>上述的配置会定义并注册一系列的LTW相关的Bean。默认的<code>LoadTimeWeaver</code>的实现类<code>DefaultContextLoadTimeWeaver</code>，它是一个包装类，他会装饰自动检测到的<code>LoadTimeWeaver</code>的实现类。</p>
<ul>
<li>对于WebLogic, WebSphere, Resin, GlassFish, JBoss这些服务器的最近的一些版本提供的类加载器是支持本地织入的，所以只需要直接激活LTW即可。</li>
<li><p>对于Tomcat6，默认的类加载器不支持<code>class transformation</code>，需要使用Spring提供的类加载器<code>TomcatInstrumentableClassLoader</code></p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"/myWebApp"</span> <span class="attr">docBase</span>=<span class="string">"/my/webApp/location"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">Loader</span></span></div><div class="line">    <span class="attr">loaderClass</span>=<span class="string">"org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader"</span>/&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>对于普通的Java应用，JDK agent是唯一的解决办法。Spring提供了<code>InstrumentationLoadTimeWeaver</code>，但是需要Spring特定的VM agent。</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-javaagent:/path/to/org<span class="selector-class">.springframework</span><span class="selector-class">.instrument-</span>&#123;version&#125;.jar</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="给EntityManagerFactory设置LoadTimeWeaver"><a href="#给EntityManagerFactory设置LoadTimeWeaver" class="headerlink" title="给EntityManagerFactory设置LoadTimeWeaver"></a>给EntityManagerFactory设置LoadTimeWeaver</h3><p>Spring 4.3之前可能需要手动的设置LoadTimeWeaver，<a href="https://jira.spring.io/browse/SPR-10856" target="_blank" rel="external">这里</a>是相关的问题。手动设置的方法是调用<code>LocalContainerEntityManagerFactoryBean#setLoadTimeWeaver</code>方法。对于Spring Boot，可以用下面的方式来设置</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line">    <span class="meta">@ConditionalOnMissingBean</span></div><div class="line">    <span class="keyword">public</span> EntityManagerFactoryBuilder entityManagerFactoryBuilder(</div><div class="line">            JpaVendorAdapter jpaVendorAdapter) &#123;</div><div class="line">        EntityManagerFactoryBuilder builder = new EntityManagerFactoryBuilder(</div><div class="line">                jpaVendorAdapter, <span class="keyword">this</span>.jpaProperties.getProperties(),</div><div class="line">                <span class="keyword">this</span>.persistenceUnitManager);</div><div class="line">        builder.setCallback(getVendorCallback());</div><div class="line">        <span class="keyword">return</span> builder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> EntityManagerFactoryBuilder.EntityManagerFactoryBeanCallback getVendorCallback() &#123;</div><div class="line">        <span class="keyword">return</span> factory -&gt; factory.setLoadTimeWeaver(loadTimeWeaver);</div><div class="line">    &#125;</div><div class="line">```    </div><div class="line"></div><div class="line">### 使用bytecode instrumentation后对Jackson带来的影响</div><div class="line"></div><div class="line">使用织入后，实体对象会包含额外的FieldHandler属性，Jackson进行序列化时会出错，需要忽略掉这行属性。</div></pre></td></tr></table></figure>
<p>@JsonIgnoreType<br>private class MixInForFieldInterceptor {<br>}</p>
<p>objectMapper.addMixIn(FieldHandler.class, MixInForFieldInterceptor.class);<br>```   </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;Hibernate在使用OneToOne的反向关联或者使用主键关联（PrimaryKeyJoinColumn）时，会出来懒加载不起的作用的情况。究其原因，Hibernate的能够进行懒加载的前提是返回的关联对象是个代理对象。如果Hibernate不能确定关联的对象是否为空，那么他们不能直接返回代理对象，因为代理对象本身就是不为空的，它不得不去检查关联对象是否存在。但是用SELECT语句去检查存在性，还不如索性直接把查询结果返回，这也就导致了懒加载的失效。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hibernate" scheme="http://yukinami.github.io/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate的Fetch问题</title>
    <link href="http://yukinami.github.io/2016/04/21/Hibernate%E7%9A%84Fetch%E9%97%AE%E9%A2%98/"/>
    <id>http://yukinami.github.io/2016/04/21/Hibernate的Fetch问题/</id>
    <published>2016-04-21T07:40:04.000Z</published>
    <updated>2016-04-22T05:04:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>下面的内容基于JPA的Hibernate实现进行讨论。</p>
<p>JPA的关联关系中的single-ended的关联（也就是ToOne）的模式fetch类型是的eager的。 在使用<code>EntityMangerd#find</code>方法进行查找时，这些关联会通过JOIN的方式被查询出来。但是如果使用Criteria API或者JPQL进行查询时，会发现针对这些关联产生了额外的SELECT查询，也就是通常我们所说的N+1的问题。</p>
<a id="more"></a>
<h2 id="Hibernate-Fetching-strategies"><a href="#Hibernate-Fetching-strategies" class="headerlink" title="Hibernate Fetching strategies"></a>Hibernate Fetching strategies</h2><p>这里需要先讨论下Hibernate的fetch策略的问题。在Hibernate的映射文件（或者注解）中可以通过fetch属性来告诉Hibernate如何fetch关联对象。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">set</span> <span class="built_in">name</span>=<span class="string">"permissions"</span></div><div class="line">            fetch=<span class="string">"join"</span>&gt;</div><div class="line">    &lt;key column=<span class="string">"userId"</span>/&gt;</div><div class="line">    &lt;one-<span class="keyword">to</span>-many <span class="built_in">class</span>=<span class="string">"Permission"</span>/&gt;</div><div class="line">&lt;/<span class="keyword">set</span></div><div class="line">&lt;many-<span class="keyword">to</span>-one <span class="built_in">name</span>=<span class="string">"mother"</span> <span class="built_in">class</span>=<span class="string">"Cat"</span> fetch=<span class="string">"join"</span>/&gt;</div></pre></td></tr></table></figure>
<p>上面的例子中，使用join的方式来fetch mother属性，也间接的表明mother关联是eager的。 但是这里声明的fetch策略仅仅对下面几种情况有效</p>
<ul>
<li>通过<code>get()</code>或者<code>load()</code>方法获取<br>— 当被作为关联引用到的时候产生的隐式获取</li>
<li><code>Criteria</code>查询</li>
<li>使用HQL查询并且声明的是subselect fetching</li>
</ul>
<p>既然映射文件中声明的fetch策略对Criteria查询有效，但是为何使用JPA的Criteria接口时又没有使用JOIN来关联呢？</p>
<h3 id="Hibernate对JPA-Criteria接口的实现"><a href="#Hibernate对JPA-Criteria接口的实现" class="headerlink" title="Hibernate对JPA Criteria接口的实现"></a>Hibernate对JPA Criteria接口的实现</h3><p>Hibernate对JPA的Criteria接口返回的<code>TypedQuery</code>实现类是<code>CriteriaQueryTypeQueryAdapter</code>，可以看到Hibernate对JPA返回的Criteria对象的编译的过程实际是转换成JPQL的查询。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;X&gt; getResultList() &#123;</div><div class="line">	<span class="function"><span class="keyword">return</span> jpqlQuery.<span class="title">getResultList</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而Hibernate对于JPQL的实现则最终又是通过HQL来实现了。这就可以解释其原因了。那么对于使用JPA接口的情况下，只有3中情况可以使用到映射文件中定义的fetch策略。</p>
<h3 id="Eager对HQL的影响"><a href="#Eager对HQL的影响" class="headerlink" title="Eager对HQL的影响"></a>Eager对HQL的影响</h3><p>对于声明成eager的关联，那么他们最终一定会去获取到这个关联。使用HQL的情况，如果HQL中通过FETCH JOIN来进行了关联，那并没有什么问题。 但是如果没有关联，那么Hibernate则会额外产生一条SELECT语句来对eager的关联进行进行查找。 也就是说如果实体中有eager关联的属性，为了避免产生N+1问题，不管我们是否需要这个关联属性必须显示的FETCH这个关联。</p>
<h2 id="EntityGraph"><a href="#EntityGraph" class="headerlink" title="EntityGraph"></a>EntityGraph</h2><p>EntityGraph可以运行时动态的覆盖映射文件中定义的FetchType。实际加载EntityGraph有两种方式</p>
<ul>
<li>FETCH 对于EntityGraph声明的属性使用eager，未声明的属性使用lazy</li>
<li>LOAD  对于EntityGraph声明的属性使用eager，未声明的属性使用他们在映射文件中声明的默认的fetch类型</li>
</ul>
<p>Hibernate对于EntityGraph的实现是使用了FetchProfile。但是FetchProfile本身实在EntityGraph之前诞生的，它用于覆盖映射文件的中fetchMode，而不是fetchType。 也就导致了使用Hibernate作为JPA实现时，FETCH和LOAD两种方式是一样的，并不能覆盖原来在映射文件中的eager为lazy。作为原因就是上面提到的JPQ中无论是Criteria API还是JPQL都是使用HQL来实现的，而HQL是无法实现覆盖eager关联的。 <a href="https://hibernate.atlassian.net/browse/HHH-8776" target="_blank" rel="external">这里</a>是相关问题的讨论。</p>
<p>最终在EntityGraph中声明的属性相当于声明了它需要使用JOIN来进行fetch。</p>
<h2 id="EAGER-fetching不一致"><a href="#EAGER-fetching不一致" class="headerlink" title="EAGER fetching不一致"></a>EAGER fetching不一致</h2><p>通过上面的内容我们可以发现，对于eager的关联，在不用的使用场景下（find，JPQL），会产生不一致的结果。所以eager join看起来是一个代码中的<a href="https://dzone.com/articles/eager-fetching-code-smell" target="_blank" rel="external">坏味道</a>。 所以推荐在global fetch plan（映射文件）中，定义所有的关联为lazy，而在每个具体的查询中来定义fetch策略。</p>
<p>下面是用Hibernate官方文档中的一段引用</p>
<blockquote>
<p>Usually, the mapping document is not used to customize fetching. Instead, we keep the default behavior, and override it for a particular transaction, using left join fetch in HQL.</p>
</blockquote>
<h2 id="Spring-Data-JPA中的实现"><a href="#Spring-Data-JPA中的实现" class="headerlink" title="Spring Data JPA中的实现"></a>Spring Data JPA中的实现</h2><p>Spring Data JPA可以通过接口的Query Method方法签名自动的来实现JPA的调用逻辑，它的调用是通过JPA Criteria API来实现的，所以最终也是无法使用映射文件文件的fetch策略的。推荐的方式是使用@Query的话直接在JPQL的声明需要fetch的关联；使用Spring Data JPA自动生成的时候使用EntityGraph来fetch。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面的内容基于JPA的Hibernate实现进行讨论。&lt;/p&gt;
&lt;p&gt;JPA的关联关系中的single-ended的关联（也就是ToOne）的模式fetch类型是的eager的。 在使用&lt;code&gt;EntityMangerd#find&lt;/code&gt;方法进行查找时，这些关联会通过JOIN的方式被查询出来。但是如果使用Criteria API或者JPQL进行查询时，会发现针对这些关联产生了额外的SELECT查询，也就是通常我们所说的N+1的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hibernate" scheme="http://yukinami.github.io/tags/Hibernate/"/>
    
      <category term="JPA" scheme="http://yukinami.github.io/tags/JPA/"/>
    
      <category term="Spring Data JPA" scheme="http://yukinami.github.io/tags/Spring-Data-JPA/"/>
    
  </entry>
  
  <entry>
    <title>如何高效的使用postman</title>
    <link href="http://yukinami.github.io/2016/03/19/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E7%9A%84%E4%BD%BF%E7%94%A8postman/"/>
    <id>http://yukinami.github.io/2016/03/19/如何高效的使用postman/</id>
    <published>2016-03-19T05:59:46.000Z</published>
    <updated>2016-03-19T07:01:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>POSTMAN目前在我们团队中一直作为一个调用API的测试工具，但是由于我们的一直深入的使用它，导致使用的过程中存在不少很低效的问题。POSTMAN本身提供很多强大的功能，用好了它完全可以成为开发过程中比不可少的开发工具。</p>
<a id="more"></a>
<h2 id="将POSTMAN作为API文档"><a href="#将POSTMAN作为API文档" class="headerlink" title="将POSTMAN作为API文档"></a>将POSTMAN作为API文档</h2><p>我认为一个非常完善的RESTful API，应该提供下面的这些特性。</p>
<ol>
<li>HATEOAS <a href="https://spring.io/understanding/HATEOAS" target="_blank" rel="external">这里</a>可以做个简单的直观的了解。有了HATEOAS的支持，客户端不需要去查看API文档就能够知道如何调用接口，也不需要自己去拼接请求URL。而且通常只有很好地实现了RESTful的接口，才能实现HATEOAS，还是设计良好的接口的体现。</li>
<li>ALPS ALPS可以说的接口IO的META描述。通过它可以更准确的描述接口。<blockquote>
<p>ALPS is a data format for defining simple descriptions of application-level semantics, similar in complexity to HTML microformats. An ALPS document can be used as a profile to explain the application semantics of a document with an application-agnostic media type (such as HTML, HAL, Collection+JSON, Siren, etc.). This increases the reusability of profile documents across media types.</p>
</blockquote>
</li>
</ol>
<p>这是我们API实现的一个目标，但是在上述的内容没有很好的被实现的情况下，提供API文档是很必要的。在之前我尝试过使用<a href="http://swagger.io/" target="_blank" rel="external">swagger</a>来描述接口，但是swagger的描述文件的书写比较繁琐，第三方的自动生成swagger描述文件的springfox以及swagger-ui一直有不少的问题，达不到一个理想的状态。</p>
<p>因此我们不妨直接使用POST来作为API的文档，一个好的文档不仅要有接口的文字描述，同时还可以提供UI进行直接调用，POSTMAN完全满足这些需求。 另外还好一个好处是，这个文档书写几乎是没有任何的额外成本的，因为开发人员本身也需要POSTMAN来调试接口。让开发人员来书写这个文档，既准确又省时省力。</p>
<p>另外POSTMAN提供了导入导出以及Shared的功能，即便不适用Team相关的功能，也能够在团队中较好的分享分档。</p>
<h2 id="POST使用中的一些问题"><a href="#POST使用中的一些问题" class="headerlink" title="POST使用中的一些问题"></a>POST使用中的一些问题</h2><h3 id="环境的问题"><a href="#环境的问题" class="headerlink" title="环境的问题"></a>环境的问题</h3><p>开发人员开发完的接口文档是的接口URL地址通常是指向本地的localhost环境的，但是提供给其他团队成员的接口通常是需要调用另外一台服务器的，其他成员不得不再次去修改URL的部分内容，非常繁琐。</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>这个问题可以通过POSTMAN的Environment的功能来解决。因为两边的调用接口不同的只是HOSTNAME和端口，因此可以把这部分定义为环境变量。</p>
<p><img src="/img/postman-environment-define.png" alt="postman-environment-define"></p>
<p>然后在其他地方引用即可，POSTMAN中引用环境变量的方式是<code></code>。</p>
<p><img src="/img/postman-environment-usage.png" alt="postman-environment-usage"></p>
<p>类似的，不同环境下的用户名密码也可以通过这种方式来解决。</p>
<h3 id="Token的问题"><a href="#Token的问题" class="headerlink" title="Token的问题"></a>Token的问题</h3><p>POSTMAN的验证方式中并不提供OAuth2的Password验证方式，这也给我们造成了不少麻烦。我们不得不每次先得请求Token的接口，然后复制下返回的Token值，然后粘贴到<code>Authorization</code>头中。这个动作其实相当的低效，特别是在开发环境需要不停的重启服务器的情况下。</p>
<h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><p>POSTMAN提供了Pre-request Scirpt和Tests这两个功能，分别在请求之前和请求之后，利用代码进行一些扩展或者额外的操作。</p>
<p>这里我们可以通过在请求Token的接口中，定义如下Tests脚本</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">var</span> <span class="class"><span class="keyword">data</span> = <span class="type">JSON</span>.parse(<span class="title">responseBody</span>);</span></div><div class="line"><span class="title">postman</span>.setEnvironmentVariable(<span class="string">"accessToken"</span>, <span class="class"><span class="keyword">data</span>.access_token);</span></div><div class="line"><span class="title">postman</span>.setEnvironmentVariable(<span class="string">"refreshToken"</span>, <span class="class"><span class="keyword">data</span>.refresh_token);</span></div></pre></td></tr></table></figure>
<p>然后每个请求的<code>Authorization</code>头中直接应用这个环境变量，就可以省去复制粘贴的操作了。</p>
<p><img src="/img/authorization-token.png" alt="authorization-token"></p>
<h2 id="其他一些功能的使用"><a href="#其他一些功能的使用" class="headerlink" title="其他一些功能的使用"></a>其他一些功能的使用</h2><h3 id="Tests"><a href="#Tests" class="headerlink" title="Tests"></a>Tests</h3><p>Tests功能本身的设计使用来进行测试的，其中可以书写类似下面的断言</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tests<span class="string">[“Body contains user_id”]</span> = responseBody.has(“user_id”)</div></pre></td></tr></table></figure>
<p>然后在POSTMAN中可以查看结果</p>
<p><img src="https://www.getpostman.com/img/v1/docs/source/cr-6.png" alt="postman-tests-result"></p>
<p>甚至可以通过Runner来批量的跑接口测试，实现E2E的回归测试等。</p>
<p><img src="/img/postman-runner.png" alt="postman-runner"></p>
<h3 id="Generate-Code"><a href="#Generate-Code" class="headerlink" title="Generate Code"></a>Generate Code</h3><p>POSTMAN还提供给了一个小功能，能够把POSTMAN中的请求，转换成其他语言的代码，方便在代码中集成或者调试。</p>
<p><img src="/img/post-man-generate-code.png" alt="post-man-generate-code"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;POSTMAN目前在我们团队中一直作为一个调用API的测试工具，但是由于我们的一直深入的使用它，导致使用的过程中存在不少很低效的问题。POSTMAN本身提供很多强大的功能，用好了它完全可以成为开发过程中比不可少的开发工具。&lt;/p&gt;
    
    </summary>
    
    
      <category term="API" scheme="http://yukinami.github.io/tags/API/"/>
    
      <category term="POSTMAN" scheme="http://yukinami.github.io/tags/POSTMAN/"/>
    
  </entry>
  
  <entry>
    <title>Spring OAuth2的ResourceServerConfiguration匹配了所有资源路径</title>
    <link href="http://yukinami.github.io/2016/03/04/Spring-OAuth2%E7%9A%84ResourceServerConfiguration%E5%8C%B9%E9%85%8D%E4%BA%86%E6%89%80%E6%9C%89%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84/"/>
    <id>http://yukinami.github.io/2016/03/04/Spring-OAuth2的ResourceServerConfiguration匹配了所有资源路径/</id>
    <published>2016-03-04T05:35:24.000Z</published>
    <updated>2016-03-04T13:57:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>通过继承<code>ResourceServerConfigurerAdapter</code>来配置ResourceServer的资源权限时，虽然使用了<code>HttpSecurity#requestMatchers</code>方法来匹配特定的资源，但是其他未匹配的资源依然会被匹配保护。</p>
<p>github上同样的<a href="https://github.com/spring-projects/spring-security-oauth/issues/444" target="_blank" rel="external">问题</a>。</p>
<a id="more"></a>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>这在使用spring-security-oauth的2.0.9之前的版本配合Spring Security 4时会出现这个问题。原因是Spring Security 4.x版本稍微修改了request matchers的规则。多次调用<code>HttpSecurity#requestMatchers</code>不会覆盖之前的调用。 2.0.9做了如下<a href="https://github.com/spring-projects/spring-security-oauth/commit/21fce68a2a28794e7627f8e25500e760b352e349" target="_blank" rel="external">修改</a></p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (endpoints != <span class="literal">null</span>) &#123;</div><div class="line">  			<span class="comment">// Assume we are in an Authorization Server</span></div><div class="line"> -			requests.requestMatchers(<span class="keyword">new</span> <span class="type">NotOAuthRequestMatcher</span>(endpoints</div><div class="line"> -					.oauth2EndpointHandlerMapping()));</div><div class="line"> +			http.requestMatcher(<span class="keyword">new</span> <span class="type">NotOAuthRequestMatcher</span>(endpoints.oauth2EndpointHandlerMapping()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>Spring Security 4需要使用Spring Security OAuth 2.0.9及以上的版本，如果使用Spring Boot，则需要使用1.3.3级以上版本，1.3.2依赖的依然是Spring Security OAuth 2.0.8版本。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;通过继承&lt;code&gt;ResourceServerConfigurerAdapter&lt;/code&gt;来配置ResourceServer的资源权限时，虽然使用了&lt;code&gt;HttpSecurity#requestMatchers&lt;/code&gt;方法来匹配特定的资源，但是其他未匹配的资源依然会被匹配保护。&lt;/p&gt;
&lt;p&gt;github上同样的&lt;a href=&quot;https://github.com/spring-projects/spring-security-oauth/issues/444&quot;&gt;问题&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring Security" scheme="http://yukinami.github.io/tags/Spring-Security/"/>
    
      <category term="Spring OAuth" scheme="http://yukinami.github.io/tags/Spring-OAuth/"/>
    
      <category term="经验总结" scheme="http://yukinami.github.io/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot Auto Configuration和HATEOAS、Data REST</title>
    <link href="http://yukinami.github.io/2016/02/26/Spring-Boot-Auto-Configuration%E5%92%8CHATEOAS%E3%80%81Data-REST/"/>
    <id>http://yukinami.github.io/2016/02/26/Spring-Boot-Auto-Configuration和HATEOAS、Data-REST/</id>
    <published>2016-02-26T12:34:05.000Z</published>
    <updated>2016-02-29T07:30:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-Boot集成HATEOAS"><a href="#Spring-Boot集成HATEOAS" class="headerlink" title="Spring Boot集成HATEOAS"></a>Spring Boot集成HATEOAS</h2><p><code>JacksonAutoConfiguration</code>会注册Primary ObjectMapper，这个ObjectMapper通过<code>spring.jackson.*</code>来配置。<br><code>JacksonAutoConfiguration</code>配置完后会注册<code>HypermediaAutoConfiguration</code>，<code>HypermediaAutoConfiguration</code>中会对Primary ObjectMapper注册<code>Jackson2HalModule</code>（由apply-to-primary-object-mapper决定）。</p>
<a id="more"></a>
<p>HypermediaConfiguration</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerHalModule</span><span class="params">(ObjectMapper objectMapper)</span> </span>&#123;</div><div class="line">	objectMapper.registerModule(<span class="keyword">new</span> Jackson2HalModule());</div><div class="line">	Jackson2HalModule.HalHandlerInstantiator instantiator = <span class="keyword">new</span> Jackson2HalModule.HalHandlerInstantiator(</div><div class="line">			HalObjectMapperConfiguration.<span class="keyword">this</span>.relProvider,</div><div class="line">			HalObjectMapperConfiguration.<span class="keyword">this</span>.curieProvider);</div><div class="line">	objectMapper.setHandlerInstantiator(instantiator);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Spring Boot使用<code>Jackson2HalModule</code>来把HAL相关的ObjectMapper配置适用到上下文环境中的Primary ObjectMapper中。 这允许HAL格式的响应能够发送给<em>application/json</em>的请求。这就导致了一个副作用，HAL特定的功能污染了Primary ObjectMapper。</p>
<p>Spring Boot 1.3.0中作了一系列修改来简化ObjectMapper的配置。</p>
<p>需改中提到</p>
<blockquote>
<p>Previously, Boot used Jackson2HalModule to apply the HAL-related<br>ObjectMapper configuration to the context’s primary ObjectMapper. This<br>was to allow HAL-formatted responses to be sent for requests accepted<br>application/json (see gh-2147). This had the unwanted side-effect of<br>polluting the primary ObjectMapper with HAL-specific functionality.<br>Furthermore, Jackson2HalModule is an internal of Spring HATEOAS that<br>@olivergierke has asked us to avoid using.</p>
<p>This commit replaces the use of Jackson2HalModule with a new approach.<br>Now, the message converters of any RequestMappingHandlerAdapter beans<br>are examined and any TypeConstrainedMappingJackson2HttpMessageConverter<br>instances are modified to support application/json in addition to their<br>default support for application/hal+json. This behaviour can be disabled<br>by setting spring.hateoas.use-hal-as-default-json-media-type to false.<br>This property is named after Spring Data REST’s configuration option<br>which has the same effect when using Spring Data REST. The new property<br>replaces the old spring.hateoas.apply-to-primary-object-mapper property.</p>
</blockquote>
<p>这次提交使用了一个新方法来替换<code>Jackson2HalModule</code>的使用。现在所有的RequestMappingHandlerAdapter的message converters会被检查，并且任何<code>TypeConstrainedMappingJackson2HttpMessageConverter</code>实例会被修改来支持<em>application/json</em>以及它们默认支持的<em>application/hal+json</em>。 这个行为可以通过设置<code>spring.hateoas.use-hal-as-default-json-media-type</code>为<code>false</code>来关闭。这个属性根据Spring Data REST的配置选项来命名，并且和使用Spring Data REST时有相同的作用。</p>
<p>Spring Data Rest中注册的<code>TypeConstrainedMappingJackson2HttpMessageConverter</code>也是这样的逻辑</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">@<span class="function">Bean</span></div><div class="line"><span class="keyword">public</span> TypeConstrainedMappingJackson2HttpMessageConverter <span class="title">halJacksonHttpMessageConverter</span>(<span class="params"></span>) &#123;</div><div class="line"></div><div class="line">	ArrayList&lt;MediaType&gt; mediaTypes = <span class="keyword">new</span> ArrayList&lt;MediaType&gt;();</div><div class="line">	mediaTypes.<span class="keyword">add</span>(MediaTypes.HAL_JSON);</div><div class="line"></div><div class="line">	<span class="comment">// Enable returning HAL if application/json is asked if it's configured to be the default type</span></div><div class="line">	<span class="keyword">if</span> (config().useHalAsDefaultJsonMediaType()) &#123;</div><div class="line">		mediaTypes.<span class="keyword">add</span>(MediaType.APPLICATION_JSON);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> order = config().useHalAsDefaultJsonMediaType() ? Ordered.LOWEST_PRECEDENCE - <span class="number">10</span></div><div class="line">			: Ordered.LOWEST_PRECEDENCE - <span class="number">1</span>;</div><div class="line"></div><div class="line">	TypeConstrainedMappingJackson2HttpMessageConverter converter = <span class="keyword">new</span> ResourceSupportHttpMessageConverter(order);</div><div class="line">	converter.setObjectMapper(halObjectMapper());</div><div class="line">	converter.setSupportedMediaTypes(mediaTypes);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> converter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样的话默认的ObjectMapper就不会被HAL特性污染。<code>TypeConstrainedMappingJackson2HttpMessageConverter</code>支持转换的HAL对象（Resource）不管请求的是<em>application/json</em>还是<em>application/hal+json</em>都能够被正确的转换。</p>
<h2 id="Spring-Boot集成Sring-Data-Rest"><a href="#Spring-Boot集成Sring-Data-Rest" class="headerlink" title="Spring Boot集成Sring Data Rest"></a>Spring Boot集成Sring Data Rest</h2><p>另外，此次修改中还提到</p>
<blockquote>
<p>Previously, when Spring Data REST was on the classpath,<br>JacksonAutoConfiguration would be switched off resulting in the context<br>containing multiple ObjectMappers, none of which was primary.</p>
<p>This commit configures RepositoryRestMvcAutoConfiguration to run after<br>JacksonAutoConfiguration. This gives the latter a chance to create its<br>primary ObjectMapper before the former adds its ObjectMapper beans to<br>the context.</p>
</blockquote>
<p>之前当Spring Data REST在classpath中时，JacksonAutoConfiguration会被自动关闭，导致上下文环境包含多个ObjectMapper，并且没有一个是primary的。也就是说<code>RepositoryRestMvcConfiguration</code>中注册的ObjectMapper同样也会被<code>JacksonHttpMessageConvertersConfiguration</code>中配置的MessageConverter使用，同样可能会导致HAL污染的问题。</p>
<p>这次提交修改成配置<code>RepositoryRestMvcAutoConfiguration</code>在<code>JacksonAutoConfiguration</code>之后执行。这给了后者在前者添加它的ObjectMapper之前，创建primary ObjectMapper的机会。最终达到了隔离ObjectMapper的目录。</p>
<p>另外Spring Boot中对于ObjectMapper配置的属性也会套用到<code>RepositoryRestMvcAutoConfiguration</code>中定义的ObjectMapper</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringBootRepositoryRestConfigurer</span> <span class="keyword">extends</span> <span class="title">RepositoryRestConfigurerAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Autowired</span>(required = <span class="literal">false</span>)</div><div class="line">	<span class="keyword">private</span> <span class="type">Jackson2ObjectMapperBuilder</span> objectMapperBuilder;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	public void configureJacksonObjectMapper(<span class="type">ObjectMapper</span> objectMapper) &#123;</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.objectMapperBuilder != <span class="literal">null</span>) &#123;</div><div class="line">			<span class="keyword">this</span>.objectMapperBuilder.configure(objectMapper);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="自定义MediaType的问题"><a href="#自定义MediaType的问题" class="headerlink" title="自定义MediaType的问题"></a>自定义MediaType的问题</h2><p>在1.3.0之前，请求<em>application/vnd.xxx.v2.5.hal+json</em>这样的自定义头，由于HAL污染的原因，并且<code>MappingJackson2HttpMessageConverter</code>默认支持<em>application/json</em>以及<em>application/\</em>+json<em>是能够正确返回HAL格式的。 现在虽然<code>TypeConstrainedMappingJackson2HttpMessageConverter</code>也支持</em>application/json*，但是由于自定义的头并不符合，所以并不能正确返回HAL格式的响应。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>注册一个带有通配符的MediaType到<code>TypeConstrainedMappingJackson2HttpMessageConverter</code>中，让其能够处理自定义版本头。另外，由于<code>HalMessageConverterSupportedMediaTypeCustomizer</code>会添加<em>application/json</em>的头兼容JSON请求，需要再其之后添加，否则会被覆盖。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="meta">@DependsOn</span>(<span class="string">"halMessageConverterSupportedMediaTypeCustomizer"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> HalVersionMessageConverterSupportedMediaTypesCustomizer <span class="title">registerCustomMediaType</span><span class="params">(@Qualifier(<span class="string">"halJacksonHttpMessageConverter"</span>)</span> TypeConstrainedMappingJackson2HttpMessageConverter halJacksonHttpMessageConverter) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> HalVersionMessageConverterSupportedMediaTypesCustomizer();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">HalVersionMessageConverterSupportedMediaTypesCustomizer</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HAL_JACKSON_HTTP_MESSAGE_CONVERTER_BEAN_NAME = <span class="string">"halJacksonHttpMessageConverter"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> BeanFactory beanFactory;</div><div class="line"></div><div class="line">    <span class="meta">@PostConstruct</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customizedSupportedMediaTypes</span><span class="params">()</span> </span>&#123;</div><div class="line">        TypeConstrainedMappingJackson2HttpMessageConverter halJacksonHttpMessageConverter = beanFactory.getBean(HAL_JACKSON_HTTP_MESSAGE_CONVERTER_BEAN_NAME, TypeConstrainedMappingJackson2HttpMessageConverter.class);</div><div class="line">        List&lt;MediaType&gt; supportedMediaTypes = <span class="keyword">new</span> ArrayList&lt;&gt;(halJacksonHttpMessageConverter.getSupportedMediaTypes());</div><div class="line">        supportedMediaTypes.add(<span class="keyword">new</span> MediaType(<span class="string">"application"</span>, <span class="string">"*+hal+json"</span>));</div><div class="line">        halJacksonHttpMessageConverter.setSupportedMediaTypes(supportedMediaTypes);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Spring-Boot集成HATEOAS&quot;&gt;&lt;a href=&quot;#Spring-Boot集成HATEOAS&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot集成HATEOAS&quot;&gt;&lt;/a&gt;Spring Boot集成HATEOAS&lt;/h2&gt;&lt;p&gt;&lt;code&gt;JacksonAutoConfiguration&lt;/code&gt;会注册Primary ObjectMapper，这个ObjectMapper通过&lt;code&gt;spring.jackson.*&lt;/code&gt;来配置。&lt;br&gt;&lt;code&gt;JacksonAutoConfiguration&lt;/code&gt;配置完后会注册&lt;code&gt;HypermediaAutoConfiguration&lt;/code&gt;，&lt;code&gt;HypermediaAutoConfiguration&lt;/code&gt;中会对Primary ObjectMapper注册&lt;code&gt;Jackson2HalModule&lt;/code&gt;（由apply-to-primary-object-mapper决定）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring Boot" scheme="http://yukinami.github.io/tags/Spring-Boot/"/>
    
      <category term="REST" scheme="http://yukinami.github.io/tags/REST/"/>
    
  </entry>
  
  <entry>
    <title>Spring自定义Constraints的ErrorCode</title>
    <link href="http://yukinami.github.io/2016/02/18/Spring%E8%87%AA%E5%AE%9A%E4%B9%89Constraints%E7%9A%84ErrorCode/"/>
    <id>http://yukinami.github.io/2016/02/18/Spring自定义Constraints的ErrorCode/</id>
    <published>2016-02-18T09:40:31.000Z</published>
    <updated>2016-02-18T10:02:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>如果使用自定义Constraints，ErrorCode的是根据Constraints的名称按照优先度生成的<code>{Constraints名}.{类名}.{字段名}</code>、<code>{Constraints名}.{字段名}</code>、<code>{Constraints名}.{字段类型}</code>、<code>{Constraints名}</code>。 在注解中定义的message会优先给Bean Validation解析，然后使用解析的结果作为Default Message，ErrorCode作为key，到Spring的MessageSource中再进行一次解析，获得最终的message template。</p>
<p>另外被验证字段本身的名称，再加上注解中除了<code>message</code>，<code>groups</code>，<code>payload</code>属性定义的其他属性的值，会作为key再次到MessageSource进行解析，结果的结果作为变量传入到上面的message template中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果使用自定义Constraints，ErrorCode的是根据Constraints的名称按照优先度生成的&lt;code&gt;{Constraints名}.{类名}.{字段名}&lt;/code&gt;、&lt;code&gt;{Constraints名}.{字段名}&lt;/code&gt;、&lt;code&gt;{Con
    
    </summary>
    
    
      <category term="Spring Framework" scheme="http://yukinami.github.io/tags/Spring-Framework/"/>
    
  </entry>
  
  <entry>
    <title>JPA fetch join &amp; N+1</title>
    <link href="http://yukinami.github.io/2016/02/17/JPA%20fetch%20join%20&amp;%20N+1/"/>
    <id>http://yukinami.github.io/2016/02/17/JPA fetch join &amp; N+1/</id>
    <published>2016-02-17T06:33:44.000Z</published>
    <updated>2016-02-17T07:43:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>JPA对于关联属性的加载时机，可以通过<code>FetchType</code>来定义<code>EAGER</code>或者<code>LAZY</code>，但是对于加载的方式，是使用SELECT、SUBSELEC、JOIN则是由provider来决定的。JPA并没有提供相关的定义。例如，在使用Hibernate作为proider时，即便定义OneToMany的<code>FetchType</code>为<code>EAGER</code>, Hibernate确实会在加载对象的时候同时加载关联对象，但是却是通过SELECT方式来实现的，也就是我们常说的N+1问题，对性能有较大的影响。</p>
<a id="more"></a>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>通过JPQL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@Query("<span class="keyword">SELECT</span> u <span class="keyword">FROM</span> <span class="keyword">User</span> u <span class="keyword">JOIN</span> <span class="keyword">FETCH</span> u.roles r<span class="string">")</span></div></pre></td></tr></table></figure>
<p>或者Creteria API</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Specification&lt;User&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="function">Predicate <span class="title">toPredicate</span><span class="params">( Root&lt;User&gt; root, CriteriaQuery&lt;?&gt; criteria, CriteriaBuilder builder )</span> </span>&#123;</div><div class="line">        root.fetch( User_.roles );</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Spring-Data-JPA中的分页问题"><a href="#Spring-Data-JPA中的分页问题" class="headerlink" title="Spring Data JPA中的分页问题"></a>Spring Data JPA中的分页问题</h2><p>但是如果上面两个查询，用于在Spring Data JPA中的Pagination的分页查询的话，又报如下的错误</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">query specified join fetching, but <span class="keyword">the</span> owner <span class="keyword">of</span> <span class="keyword">the</span> fetched association was <span class="keyword">not</span> present <span class="keyword">in</span> <span class="keyword">the</span> select list</div></pre></td></tr></table></figure>
<p>意思是说，查询指定了join fetching，但是需要被fetched的关联的owner没有在select列表中出现。就比如说，我们指定了需要fetch User的roles属性，但是select中连user本身都没有出现，这个fetch就变的多余了。但是我们确实取了User对象</p>
<p>SimpleJpaRepository中对Query的构建</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">protected TypedQuery&lt;T&gt; getQuery(Specification&lt;T&gt; spec, <span class="keyword">Sort</span> <span class="keyword">sort</span>) &#123;</div><div class="line"></div><div class="line">	CriteriaBuilder builder = em.getCriteriaBuilder();</div><div class="line">	CriteriaQuery&lt;T&gt; <span class="keyword">query</span> = builder.createQuery(getDomainClass());</div><div class="line"></div><div class="line">	Root&lt;T&gt; root = applySpecificationToCriteria(spec, <span class="keyword">query</span>);</div><div class="line">	<span class="keyword">query</span>.select(root);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (<span class="keyword">sort</span> != null) &#123;</div><div class="line">		<span class="keyword">query</span>.orderBy(toOrders(<span class="keyword">sort</span>, root, builder));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> applyRepositoryMethodMetadata(em.createQuery(<span class="keyword">query</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原因在于我们查询的是Page对象，Spring除了会使用差个查询获取数据外，还会使用这个查询进行count查询，但是那个查询中没有没指定User对象。</p>
<p>解决办法是如果发现针对count查询，不指定fetch</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">new Specification<span class="tag">&lt;<span class="name">User</span>&gt;</span>() &#123;</div><div class="line">    @Override</div><div class="line">    public Predicate toPredicate( Root<span class="tag">&lt;<span class="name">User</span>&gt;</span> root, CriteriaQuery<span class="php"><span class="meta">&lt;?</span>&gt; criteria, CriteriaBuilder builder ) &#123;</span></div><div class="line">    	<span class="class"><span class="keyword">Class</span> <span class="title">clazz</span> = <span class="title">cq</span>.<span class="title">getResultType</span>();</span></div><div class="line">    	<span class="title">if</span> (<span class="title">clazz</span>.<span class="title">equals</span>(<span class="title">User</span>.<span class="title">class</span>)) &#123;</div><div class="line">    		root.fetch(User_.roles);</div><div class="line">    	&#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="分页Fetch的性能问题"><a href="#分页Fetch的性能问题" class="headerlink" title="分页Fetch的性能问题"></a>分页Fetch的性能问题</h2><p>我们知道，理想的分页是过程在数据库查询阶段就指定条件来限制返回结果的件数的。 但是我们同时又需要去JOIN子表，因为每条主表记录关联子表的记录条数是不确定的，这也就导致需要取多少条数据库返回记录变得不确定了。最终会产生如下的警告</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">7 </span>juin <span class="number">2011</span> <span class="number">09</span>:<span class="number">52</span>:<span class="number">37</span> org.hibernate.hql.ast.QueryTranslatorImpl <span class="keyword">list</span> ATTENTION: firstResult/maxResults specified with collection fetch; applying in memory!</div></pre></td></tr></table></figure>
<p>也就是说，分页的操作不能在数据库端进行了，只能查询数据库的所有记录，然后在内存中进行分页，这在数据量庞大的主表的情况是不能接受的（通常我们需要分页，也就意味着主表的记录较多）</p>
<p>所以结论上讲，类似OneToMany这样会导致结果条数不确定的JOIN，在需要分页时，是不能使用的。 所以我们只能选择SELECT或者SUBSELECT。好在就算我们使用的JPA，Hibernate的FetchMode的还是可以使用的，为了避免N+1问题，只能使用SUBSELECT。</p>
<p>NOTES：在使用Hibernate作为provider的时候，FetchMode的JOIN并没有效果，原因未知。</p>
<p>另外，指定了SUBSELECT只是指定了FetchMode，FetchType本身仍可以指定为EAGER，但是不推荐直接修改定义关联注解上的属性，因为并不能保证每个查询User的地方都希望fetch roles属性。推荐EntityGraph来实现，针对不同的查询自定义知否需要eager fetch。</p>
<p>NOTES：在使用Hibernate作为provider的时候，通过EntityGraph来指定某个关联需要eager fetch时，会导致Hibernate使用JOIN来关联而忽视定义的FetchMode。所以分页的情况，仍不能使用EntityGraph。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JPA对于关联属性的加载时机，可以通过&lt;code&gt;FetchType&lt;/code&gt;来定义&lt;code&gt;EAGER&lt;/code&gt;或者&lt;code&gt;LAZY&lt;/code&gt;，但是对于加载的方式，是使用SELECT、SUBSELEC、JOIN则是由provider来决定的。JPA并没有提供相关的定义。例如，在使用Hibernate作为proider时，即便定义OneToMany的&lt;code&gt;FetchType&lt;/code&gt;为&lt;code&gt;EAGER&lt;/code&gt;, Hibernate确实会在加载对象的时候同时加载关联对象，但是却是通过SELECT方式来实现的，也就是我们常说的N+1问题，对性能有较大的影响。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JPA" scheme="http://yukinami.github.io/tags/JPA/"/>
    
      <category term="Spring Data" scheme="http://yukinami.github.io/tags/Spring-Data/"/>
    
  </entry>
  
</feed>
